# 17.4 투명 협상

## 1. 개요

- `투명협상`: 클라이언트 입장에서 `협상하는 중개자 프락시를 둠으로써 클라이언트와의 메시지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 서버에서 제거`한다
- 프락시는 클라이언트의 기대가 무엇인지 알고 있고 클라이언트의 입장에서 협상을 수행할 수 있는 능력이 있는 것으로 가정됨(프락시는 콘텐츠에 대한 요청을 보고 클라이언트의 요구사항을 파악하고 있다)
- 투명한 내용 협상을 지원하기 위해 서버는 클라이언트의 요청에 가장 잘 맞는 것이 무엇인지 판별하려면 어떤 요청 헤더를 검사해야 하는지 프락시에게 반드시 말해줄 수 있어야 한다
- HTTP/1.1 명세는 투명 협상에 대한 어떤 메커니즘도 정의하지 않았지만, 대신 `Vary 헤더`를 정의했다
  - 서버는 응답에 `Vary 헤더`를 포함시켜 보냄으로써 중개자에게 `내용 협상을 위해 어떤 헤더를 사용하고 있는지 알려줄 수 있다`
- 캐시 프락시는 단일한 URL을 통해 접근할 수 있는 문서의 여러 다른 사본을 저장할 수 있다
  - 만약 서버가 그들의 캐시에 대한 의사결정 프로세스를 캐시에게 알려주었다면 캐시는 서버의 입장에서 클라이언트와 협상할 수 있다
  - 캐시는 또한 콘텐츠를 트랜스코딩하기에 훌륭한 장소인데 캐시안에 설치되어 있는 범용 트랜스코더는 특정 서버에 국한되지 않고 어떤 서버의 콘텐츠든 트랜스코딩할 수 있기 때문

## 2. 캐시와 얼터네이트(alternate)(17.4.1)

- 콘텐츠를 캐시하는 것은 그 콘텐츠가 나중에 재사용될 것이라고 예상하기 때문
- 캐시는 클라이언트에게 올바른 캐시된 응답을 돌려주기 위해 서버가 응답을 돌려줄 때 사용했던 의사결정 로직의 상당 부분을 그대로 사용해야 한다

  <img src="https://file.notion.so/f/s/9699def4-02b1-46d4-9685-21ee2bfd1fe7/IMG_D10F96795087-1.jpeg?id=0768e57b-83be-4e24-b21e-5cca3f210727&table=block&spaceId=033d6787-2827-41df-9122-be80d7bef061&expirationTimestamp=1681814354768&signature=m11FMokw4lqehTZC1lSp4kjkbpRnhTfnT6aG793qYaU&downloadName=IMG_D10F96795087-1.jpeg" width="300" />

- 위 그림은 캐시와 관련된 올바른 그리고 올바르지 않은 작업들의 수행 과정을 그리고 있음
- 캐시는 첫번째 요청을 서버로 그대로 전달하고 응답을 저장한다
- 두번째 응답은 캐시가 URL에 대응하는 문서을 찾아서 돌려준 것이다.
  - 그러나 이 문서는 프랑스어로 되어 있고 요청자는 스페인어 문서르 원한다
  - 만약 캐시가 프랑스어 문서를 그대로 요청자에게 돌려보낸다면 이것은 잘못된 동작이 될 것이다
- 그러므로 `캐시는 반드시 두번째 응답도 서버에게 그대로 전달하고 그 URL에 대한 이번의 응답과 지난번의 응답을 모두 저장해야 한다`
- 서버와 마찬가지로 캐시는 이제 같은 URL에 대해 두개의 문서를 갖게 된다
- 이 다른 버전은 `배리언트(variant)` 나 `얼터네이트(alternate)`로 불린다
- 따라서, `내용 협상`은 `배리언트 중에서 클라이언트 요청에 가장 잘 맞는 것을 선택하는 과정`으로 이해될 수 있다

## 3. Vary 헤더(17.4.2)

- HTTP `Vary 응답 헤더`는 `서버가 문서를 선택하거나 커스텀 콘텐츠를 생성할 때 고려한 클라이언트 요청 헤더 모두(일반적인 내용 협상 헤더 외에 추가로 더해서)를 나열`한다
  - 예를 들어 제공된 문서가 `User-Agent헤더에 의존한다면 Vary 헤더는 반드시 “User-Agent”를 포함`해야 한다
- 새 요청이 도착했을 때 캐시는 `내용 협상 헤더들을 이용해 가장 잘 맞는 것을 찾는다`
  - 그러나 캐시가 문서를 클라이언트에게 제공해줄 수 있게 되기 전에 `캐시는 반드시 캐시된 응답 안에 서버가 보낸 Vary헤더가 들어있는지 확인`해야 한다
  - 만약 존재한다면 그 Vary 헤더가 명시하고 있는 헤더들은 새 요청과 오래된 캐시된 요청에서 그 값이 서로 맞아야만 한다. 왜냐하면 서버는 클라이언트의 요청 헤더에 따라 그들의 응답이 달라질 수 있기 때문에 `투명 협상을 구현하기 위해 캐시는 반드시 캐시된 배리언트와 함게 클라이언트 요청 헤더와 그에 알맞은 서버 응답 헤더 양쪽 모두를 저장`해야 한다
- 만약 서버의 Vary 헤더가 이렇다면, 거대한 수의 다른 User-Agent 와 Cookie 값이 많은 배리언트를 만들어낼 것이다
  ```tsx
  Vary: User - Agent, Cookie;
  ```
- `캐시는 각 배리언트마다 알맞은 문서 버전을 저장해야 한다`
  - 캐시가 검색을 할 때 먼저 내용 협상 헤더로 적합한 콘텐츠를 맞춰보고 다음에 요청의 배리언트를 캐시된 배리언트와 맞춰본다. `만약 맞는 것이 없으면 캐시는 문서를 서버에서 가져온다`
