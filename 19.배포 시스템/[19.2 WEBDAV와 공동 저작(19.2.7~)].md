# 19.2 WEBDAV와 공동 저작(19.2.7~)

## 1. 속성과 META 데이터(19.2.7)

- `속성`에는 `저작자의 이름, 수정한 날짜, 내용 등급 등과 같은 리소스의 정보를 기술`
- HTML 의 META 태그는 콘텐츠 일부로써 그 정보들을 포함하는 메커니즘을 제공한다
- 하지만 많은 리소스들(바이너리 데이터와 같은)이 META 데이터에 포함될 수 없다
- WebDAV와 같은 분산 협업 시스템은 더 복잡한 속성을 가진다
  - 예를 들어 저작 속성을 생각해보면 문서가 편집될 때 이 속성은 새로운 저작자를 반영하여 갱신해야 한다
  - WebDAV용어로 그런 `동적 수정 속성`을 `‘live’ 속성`이라고 한다
  - 거의 변하지 않는 `Content-Type 과 같은 정적 속성`을 `‘dead’ 속성`이라고 한다
- 속성의 발견과 수정을 지원하기 위해 WebDAV는 PROPFIND 와 PROPPATCH라는 두가지 새로운 메서드를 포함해 HTTP를 확장한다

## 2. PROPFIND 메서드(19.2.8)

- `PROPFIND`(property find, 속성 찾기) 메서드는 `주어진 파일이나 파일 그룹(콜렉션)의 속성을 읽는 데 사용`한다
- 세가지 형식의 동작 지원
  - 모든 속성과 그 값을 요청한다
  - 선택된 속성과 그 값의 집합을 요청한다
  - 모든 속성의 이름을 요청한다
- 다음은 모든 속성과 그 값을 요청하는 예
  ```bash
  PROPFIND /ch-publish.fm HTTP/1.1
  Host: minstar.inktomi.com
  User-Agent: Mozilla/4.0 (compativle; MSIE 5.0; Windows NT)
  Depth: 0
  Cache-Control: no-cache
  Connection: Keep-Alive
  Content-Length:0
  ```
- `<propfind> 요청 요소`는 PROPFIND 메서드로부터 반환될 속성들을 기술
- 다음 목록은 PROPFIND 요청과 함께 사용하는 몇몇 XML 요소
  - `<allprop>` - 반환될 모든 속성의 이름과 값을 기술
  - `<propname>` - 반환될 속성 이름의 집합 기술
  - `<prop>` - <propfind> 요소의 하위 요소. 반환될 값의 속성을 기술. 예를 들어 “<a:prop><a:owner/>….</a:prop>” 와 같은 식이 된다
- 다음 목록은 PROPFIND 에 대한 응답에 있는 XML 요소
  - `<multistatus>` - 여러 응답을 담는 컨테이너
  - `<href>` - 리소스의 URI 를 가리킨다
  - `<status>` - 특정 요청에 대한 HTTP 상태 코드를 기술한다
  - `<propstat>` - <status> 요소 한 개와 <prop> 요소 한 개로 이루어져 있는 집합. <prop> 요소는 리소스에 대한 속성의 이름/값 쌍을 한 개 이상 포함한다
- PROPFIND 를 활용하는 한 가지 예는 `디렉터리의 목록을 얻는 것`
  - PROPFIND 요청의 표현력을 이용하면 호출 한 번으로 목록의 계층 관계 전체와 그 안에 있는 개별 엔터티의 모든 속성까지 읽어올 수 있다

## 3. PROPPATCH 메서드

- `PROPPATCH 메서드`는 `특정 리소스의 여러 속성을 설정하거나 제거하는 원자적 메커니즘을 제공`
- 원자성은 모든 요청이 성공하거나 모든 요청이 무효가 되거나 둘 중 하나만 수행하는 것을 보장한다
- PROPPATCH 메서드의 기본 XML 요소는 `<propertyupdate>` 이다
  - 이는 업데이트가 필요한 모든 속성을 담는 컨테이너 역할을 한다
  - <set> 과 <remove> XML 요소는 수행할 동작을 가리킨다
  - `<set>` - 설정할 속성을 기술한다. <set>은 리소스에 적용할 이름/값 쌍의 속성을 기술하는 한 개 이상의 <prop> 하위 요소를 포함한다. 만약 속성이 이미 존재하면, 그 값은 현재 보내는 값으로 교체된다
  - `<remove>` - 제거할 속성을 기술. <set> 과는 달리 <prop> 컨테이너에는 속성의 이름만 나열
- PROPPATCH 요청에 대한 응답은 PROPFIND 요청에 대한 응답과 매우 유사

## 4. 콜렉션과 이름공간 관리(19.2.10)

- `콜렉션`은 `사전에 정의한 계층에 있는 리소스들의 논리적 혹은 물리적 그룹`
- 콜렉션의 모범적인 예는 `디렉터리`
  - 이는 파일시스템의 디렉터리 같이 다른 리소스들의 컨테이너처럼 동작
  - 콜렉션은 다른 콜렉션을 포함(파일시스템의 디렉터리와 같다)
- WebDAV 는 XML 이름공간 메커니즘을 사용
- 이름공간을 관리하는 다섯가지 메소드 제공
  - `DELETE`
  - `MKCOL`
  - `COPY`
  - `MOVE`
  - `PROPFIND`

## 5. MKCOL 메서드(19.2.11)

- `MKCOL 메서드`는 `클라이언트가 지정된 URL에 해당하는 콜렉션을 서버에 생성`하게 한다
- 언뜻 보기에 단순히 콜렉션을 생성하는 완전히 새로운 메서드를 정의하는 것은 불필요해보일 수 있다
  - 기존의 PUT 이나 POST 메서드를 이용하면 완벽한 대체제를 만들 수 있을 것처럼 보인다
  - WebDAV 프로토콜의 설계자는 이러한 대체재를 고려하긴 했지만 아직은 여전히 새로운 메서드를 정의하는 방식을 사용한다
  - 그런 결정의 배경에는 다음과 같은 이유가 있다
    - 콜렉션을 생성할 목적으로 PUT이나 POST를 사용하려면 클라이언트는 요청 안에 추가적인 정보를 더해보는 식으로 자체적인 프로토콜을 만들어야 한다. 그렇게 사용할 수도 있지만 `즉석으로 프로토콜을 정의하는 것은 번거롭고 오류를 발생시키기 쉽다`
    - 대부분의 접근 제어 메커니즘은 메서드의 타입에 기반해 동작한다. 몇 가지 메서드만이 저장소에 있는 리소스를 생성하고 삭제할 수 있다. 만약 우리가 다른 메서드들을 본래 용도와 다르게 사용하면 이러한 접근 제어 메커니즘은 잘 동작하지 않을 것이다.

## 6. DELETE 메서드(19.2.12)

- 3장에서 이미 DELETE 메서드를 다루었는데, WebDAV는 그 의미를 콜렉션까지 확장
- 디렉터리를 지우려고 한다면 `Depth 헤더가 필요할 것이다`
  - Depth헤더가 기술되어 있지 않으면 DELETE 메서드는 Depth 헤더가 무한으로 설정되어 있다고 가정할 것이다
  - 이는 디렉터리와 그 하위에 있는 모든 디렉터리가 지워진다는 뜻이다
- 응답 역시 지워진 콜렉션을 가리키는 `Content-Location 헤더`를 포함한다
- 콜렉션을 제거하려 할 때 콜렉션이 누군가에 의해 잠겨 있어서 지울 수 없는 경우가 언제든지 생길 수 있다
  - 이 경우 콜렉션 자체는 지워지지 않을 것이며 서버는 `207 Multi-Status` 코드를 반환

## 7. COPY 와 MOVE 메서드

- MKCOL과 마찬가지로 COPY 및 MOVE 작업을 할 수 있는 다른 방법이 있다
- COPY 메서드의 대안은 리소스에 `GET 요청을 보내고 리소스를 다운 받은 다음, PUT 요청과 함께 서버에 리소스를 다시 올리는 것`이다
- MOVE 메서드도 이와 유사한 방식의 대안이 있다. 그러나 이런 방식은 다단계 콜렉션에 대한 `COPY나 MOVE 작업을 할 때 발생하는 모든 문제를 고려해봤을 때 확장이 쉽지 않다는 문제`가 있다
- COPY 와 MOVE 메서드는 요청 URL을 원본의 위치 정보로 사용하고 목적지인 Destination HTTP 헤더의 값을 목적지 정보로 사용한다
- MOVE 메서드는 COPY 메서드에 이어 몇가지 추가 작업을 수행한다
  - 그 작업은 원본지 URL 을 목적지에 복사하고 새로 생성된 URI 의 무결성을 검사하고 원본을 지운다
- C`OPY 나 MOVE 가 콜렉션을 처리할 때는 Depth 헤더에 영향을 받는다`
  - Depth 헤더가 없으면 무한대 깊이로 가정하고 수행된다
  - 만약 Depth 가 0으로 설정되면 이 메서드는 단순히 해당 리소스에만 적용이 될 것이다
  - 콜렉션을 복사하거나 이동할 경우 우너본의 속성과 같은 속성을 가지고 있는 콜렉션들만 목적지에 생성될 것이다
- 콜렉션의 내부 구성요소들은 복사나 이동되지 않는다
- Depth에 무한대 값을 기술하는 것은 MOVE메서드에서만 할 수 있다

### Overwrite헤더의 영향

- COPY 나 MOVE 메서드도 `Overwrite 헤더`를 사용할 수 있다
- Overwrite 헤더는 T나 F로 설정할 수 있다
- T로 설정하였고 목적지가 존재한다면 COPY 나 MOVE 작업을 수행하기 전에 무한대 값을 가진 Depth와 함께 DELTE 가 목적지 리소스에 수행될 것이다
- 만약 Overwrite플래그를 F로 설정하였고 목적지 리소스가 존재하면 작업은 실패할 것이다

### COPY/MOVE의 속성

- 콜렉션이나 요소를 복사하면 기본적으로 그것들의 모든 속성도 복사된다
- 하지만 요청은 작업에 대한 추가 정보를 기술한 XML 본문을 포함할 수 있다
- 여기에는 반드시 모든 속성이 성공적으로 복사되어야 한다고 기술하거나 어떤 속성만 복사하려고 하는지 기술할 수 있다
- 고려해야 할 두가지 단적인 예를 들어보자
  - COPY 나 MOVE를 CGI 프로그램이나 콘텐츠를 만들어내는 다른 스크립트로부터 생성된 페이지에 적용한다고 생각해보자. CGI 에 의해 생성된 파일을 복사하고 이동하려면 그 의미를 보존하기 위해서 WebDAV 는 해당 페이지를 생성했던 프로그램의 위치를 가리키는 `“src”와 “link” XML요소를 제공한다`
  - COPY 와 MOVE 메서드가 live 속성을 모두 복제할 수는 없을 것이다. 예를 들어 CGI 프로그램을 생각해보자. 만약 cgi-bin 디렉터리로부터 복사되었다면 이는 더는 실행되지 않을 수도 있다. 현재 WebDAV의 명세에서는, COPY 와 MOVE 는 `최선의 노력` 방식으로 처리하여 모든 정적 속성들과 적절한 live 속성을 모두 복사한다

### 잠긴 리소스와 COPY MOVE 메서드

- `리소스가 현재 잠겨 있으면  COPY 와 MOVE 모두 목적지로 잠겨있는 리소스를 이동하거나 복사하는 것이 금지된다`
- 이 두가지 모두 현재 잠겨 있는 콜렉션 아래를 목적지로 하는 COPY 와 MOVE 가 수행될 경우, 복사 혹은 이동된 리소스도 잠기게 된다

## 8. 향상된 HTTP/1.1 메서드

- WebDAV 는 HTTP 메서드인 DELETE, PUT, OPTIONS 의 의미를 수정했다
  - GET 과 HEAD의 의미는 바뀌지 않고 그대로 두었다
  - POST 요청이 수행하는 작업은 항상 특정 서버 구현에 따라서 다르며 WebDAV는 POST의 의미를 전혀 수정하지 않았다
  - DELETE 메서드는 이미 “콜렉션과 이름공간 관리” 에서 다루었다

### PUT 메서드

- WebDAV가 PUT 메서드를 따로 정의하지는 않지만 PUT 메서드는 저작자가 공용 사이트에 콘텐츠를 전송하는 유일한 방법이다
- 잠금을 제공하려고 WebDAV는 PUT 요청에 If 헤더를 추가했다
  - If 헤더에 기술되어 있는 잠금 토큰이 리소스에 있는 것과 일치한다면 PUT 작업이 수행되어야 한다
  - If헤더는 PROPPATCH, DELETE, MOVE, LOCK, UNLOCK 등과 같은 다른 메서드들과도 함께 사용된다

### OPTIONS 메서드

- 클라이언트는 OPTIONS 메서드를 사용해서 WebDAV 서버가 어떤 것들을 제공하는지 알아볼 수 있다
- OPTIONS 메서드에 대한 응답으로 오는 여러 흥미로운 헤더가 있다. 다음은 그 예들을 나열한 것이다
  - DAV 헤더는 DAV지원 클래스에 대한 정보를 제공한다. 두가지 지원 클래스가 있다
  - Class1 지원
    - 서버는 RFC 2518의 모든 절에 있는 모든 MUST 요구사항을 지원해야한다. 만약 리소스가 Class1 수준만 지원한다면 DAV 헤더의 값으로 1을 보낼 것이다
  - Class2 지원
    - Class1 요구사항 모두 지원하는 것에 더해 LOCK 메서드를 지원한다. LOCK 과 함께 Class2 를 지원하려면 Timeout과 Lock-Token 헤더를 지원해야 하고 <supportedlock> <lockdiscovery> XML 요소를 지원해야한다. DAV 헤더에 기술되어 있는 2는 Class2 를 지원한다는 뜻이다

## 9. WebDAV의 버전관리(19.2.15)

- 사실 수정한 것이 유실되는 문제를 완벽히 막으려면 잠금과 버저닝이 필수
- 버저닝과 관련된 일반적인 기능 중 일부는 이전 문서의 버전을 저장하고 접근하는 것과 변경 기록과 변경에 대한 자세한 내용이 기술된 주석을 관리하는 것
