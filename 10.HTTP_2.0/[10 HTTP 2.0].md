# 10장 HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경

HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다. 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 HTTP의 메시지 교환 방식은 단순함 면에서는 더할 나위 없었지만, **응답을 받아야만 그다음 요청을 보낼 수 있기 때문에 심각한 회전(latencty)을 피할 수 없었다.**

그러다가 2009년 구글이 웹을 더 빠르게 하겠다는 목표 아래 SPDY 프로토콜을 내놓았다. 이 프로토콜은 기존의 HTTP에 속도를 개선하기 위한 여러 기능을 추가한 것이다. SPDY는 헤더를 압축하여 대역폭을 절약했고, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능했으며, 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능도 갖추고 있다.

2023년 현시점에서 HTTP/2.0에 대한 여러 초안은 많이 나왔지만 여전히 SPDY의 특징들을 거의 유지하고 있다. 크게 변경된 점이라면 헤더를 압축할 때 더 이상 deflate(특정한 파일을 압축하는 알고리즘) 알고리즘을 사용하지 않게 되었다는 것 정도다.

<br />
<br />

## 10.2 개요

HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다. 이때 TCP 커넥션을 초기화하는 것은 클라이언트다. 프레임들에 담긴 요청과 응답은 스트림을 통해 보내진다. 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로, 여러 개의 요청과 응답을 동시에 처리하는 것 역시 가능하다. HTTP/2.0은 이들 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공한다.

HTTP/2.0은 기존의 요청-응답과는 약간 다른 **새로운 상호작용 모델인 서버 푸시를 도입했다.**

<br />
<br />

## 10.3 HTTP/1.1과의 차이점

#### 10.3.1 프레임

HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다. 아래 그림과 같이 모든 프레임은 8바이트 크기의 헤더로 시작하며, 뒤이어 최대 16,383 바이트 크기의 페이로드가 온다.

<img width="600px" alt="10장" src="https://user-images.githubusercontent.com/75570915/219361104-c34ee47b-a9d8-4dde-9d07-517b64b18741.png">

<br />

#### 10.3.2 스트림과 멀티플렉싱

스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀸스다. HTTP/1.1에서는 한 TCP 커넥션을 통해 요청을 보냈을 때, 그에 대한 응답이 도착하고 나서야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있다. **HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다.**

뿐만 아니라 스트림은 우선순위도 가질 수 있다. 네트워크 대역폭이 충분하지 않아 프레임의 전송이 느리다면, 웹 브라우저는 보다 중요한 리소스를 요청하는 스트림에게 더 높은 우선순위를 부여할 수 있을 것이다. 하지만 이 우선순위에 따르는 것은 의무사항이 아니기 때문에, 요청이 우선순위대로 처리된다는 보장은 없다.

HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없다. 동시에 여러 개의 스트림을 사용하면 스트림이 불록될 우려가 있는데, 그 때 WINDOW_UPDATE 프레임을 이용한 흐름 제어(flow contorl)를 통해, 스트림들이 서로 간섭해서 망가지는 것을 막아준다.

<br />

#### 10.3.3 헤더 압축

HTTP/1.1에서 헤더는 아무런 압축 없이 그대로 전송되었다. 과거에는 웹페이지 하나를 방분할 때의 요청이 많지 않았기 때문에 헤더의 크기가 그다지 큰 문제가 되지 않았지만, 요즈음에는 웹페이지 하나에 많은 회전 지연과 대역폭이 들어가기 때문에 문제가 된다.

이를 개선하기 위해 HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송한다. HPACK 명세에 따라 헤더를 압축하고 해제할 때 '압축 콘텍스트(compression context)'를 사용한다. 이 헤더를 받은 측에서는 반드시 압축 해제를 수행해야 한다. 만약 그럴 수 없다면 COMPRESSION_ERROR와 함께 커넥션을 끊어야 한다.

<br />

#### 10.3.4 서버 푸시

HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다. 이 기능은 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다.

리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내어 미리 알려주어야 한다. 클라이언트가 PUSH_PROMISE 프레임을 받게되면 해당 프레임의 스트림은 클라이언트 입장에서는 '예약됨(원격)' 상태가 된다. 이 상태에서 클라이언트는 RST_STREAM 프레임을 보내어 푸시를 거절할 수 있다. RST_STREAM을 보내게 되면 그 스트림은 즉각 닫히게 된다.

- 서버 푸시를 사용하기로 했더라고, 중간의 프락시가 서버로 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있으며 반대로 아무 리소스없이도 클라이언트에게 보낼 수 있다.
- 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시할 수 있다.

<br />
<br />

## 10.4 알려진 보안 이슈

#### 10.4.1 중개자 캡슐화 공격(Intermediary Encapsulation Attacks)

HTTP/2.0 메시지를 중간의 프락시(중개자)가 HTTP/1.1 메시지로 변환할 떄 메시지의 의미가 변질될 가능성이 있다. HTTP/1.1과는 달리 HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다. 이는 HTTP/2.0이 헤더 필드로 어떤 문자열이든 사용할 수 있게 해준다. 이는 정상적인 HTTP/2.0 요청이나 응답이, 불법적이거나 위조된 HTTP/1.1 메시지로 번역되는 것을 유발할 수 있다.

다행히 HTTP/1.1 메시지를 HTTP/2.0 메시지로 번역하는 과정에서는 이런 문제가 발생하지 않는다.

<br />

## 10.4.2 긴 커넥션 유지로 인한 개인정보 유출 우려

HTTP/2.0은 사용자가 요청을 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있다. 이것은 개인 정보의 유출에 악용될 가능성이 있다. 예를 들어 어떤 사용자가 브라우저를 사용할 때, 그 사용자는 이전에 그 브라우저를 사용했던 사용자가 무엇을 했는지 알아낼 가능성도 있다. 이것은 HTTP가 현재 갖고 있는 문제이기도 하지만, 짧게 유지되는 커넥션에서는 위험이 적다.
