# 7.5 적중과 부적중

캐시는 정말 유용하다. 그러나 캐시가 **세상 모든 문서의 사본을 저장하지는 않는다.**

캐시에 요청이 도착했을 때, 만약 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리될 수 있다. 이것을 **캐시 적중(cache hit)**이라고 부른다(그림 7-4a). 만약 대응하는 사본이 없다면 그냥 원 서버로 전달되기만 할 뿐이다. 이것을 **캐시 부적중(cache miss)**라고 부른다(그림 7-4b).

![7.4 적중과 부적중](https://user-images.githubusercontent.com/75570915/209662866-c2ac89f9-fb3f-4daa-8ce4-79764bec5b18.jpeg)

<br />
<br />

## 7.5.1 재검사(Revalidation)

원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 **반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다.** 이러한 '신선도 검사'를 HTTP 재검사라 부른다(그림 7-4c).

캐시는 스스로 원한다면 언제든지 사본을 재검사할 수 있다. 하지만 캐시가 가지고 있는 문서의 크기에 비해 네트워크 대역폭은 부족하기 때문에, 사본을 검사할 필요가 있을 정도로 **충분히 오래된 경우에만 재검사를 한다.**

캐시는 캐시된 사본의 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보낸다.

- 콘텐츠가 변경되지 않았을 때: 304 Not Modified 응답

그 사본이 여전히 유효함을 알게 된 캐시는 즉각 사본이 신선하다고 임시로 표시한 뒤 그 사본을 클라이언트에게 제공한다. 그리고 이것을 느린 적중이라고 부른다(그림 7-5a). 이것은 순수 캐시 적중보다는 느리다. 그 이유는 원 서버와 검사를 할 필요가 있기 때문이다. 다만, 캐시 부적중보다는 빠르다. 그 이유는 서버로부터 객체 데이터를 받아올 필요가 없기 때문이다.

![7.5 적중 vs 부적중](https://user-images.githubusercontent.com/75570915/209669375-dfdf9156-9e0b-43b7-be47-3a038da1ebb1.jpeg)

HTTP는 캐시된 객체를 재확인하기 위한 몇 가지 도구를 제공한다. 그중에서 가장 많이 쓰이는 것은 **if-Modified-Since 헤더다.** 서버에게 보내는 GET 요청에 이 헤더를 추가하면 **캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미**가 된다.

<br />

#### 재검사 적중

만약 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 **HTTP 304 Not Modified** 응답을 보낸다.

![7.6 HTTP는 재검사를 위해 if-Modified-Since 헤더를 사용한다](https://user-images.githubusercontent.com/75570915/209670279-a2a11c31-fce9-4999-82ee-50013d506e11.jpeg)

<br />

#### 재검사 부적중

만약 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 **HTTP 200 OK**응답을 클라이언트에게 보낸다.

<br />

#### 객체 삭제

만약 서버 객체가 삭제되었다면, 서버는 **404 Not Found** 응답을 돌려보내며, 캐시는 사본을 삭제한다.

<br />
<br />

## 7.5.2 적중률

**캐시가 요청을 처리하는 비율**을 캐시 적중률 혹은 문서 적중률이라고 부르기도 한다. 실제 적중률은 캐시의 크기나 캐시의 데이터가 얼마나 자주 변경되거나 개인화되어 있는지, 또는 어떻게 설정되어 있는지에 따라 달려있다. 적중률은 예측하기 어려운 것으로 악명이 높지만 오늘날 적중률 40%면 웹 캐시로 괜찮은 편이다. 보통 크기의 캐시라도 충분한 분량의 자주 쓰이는 문서들을 보관하여 상당히 트래픽을 줄이고 성능을 개선할 수 있다는 점이다.

<br />
<br />

## 7.5.3 바이트 적중률

문서들이 모두 같은 크기인 것은 아니기 때문에 문서의 적중률이 모든 것을 말해주지는 않는다. 어떤 사람들은 바이트 단위 적중률 측정값을 더 선호한다. 바이트 단위 적중률 100%는 모든 바이트가 캐시에서 왔으며, **어떤 트래픽도 인터넷으로 나가지 않았음을 의미한다.**

문서 적중률과 바이트 단위 적중률은 둘 다 캐시 성능에 대한 유용한 지표다. 

문서 적중률은 **얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여준다.** 그리고 문서 적중률을 개선하면 **전체 대기시간(지연)이 줄어든다.**

바이트 단위 적중률은 **얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여준다.** 바이트 단위 적중률의 개선은 **대역폭 절약을 최적화한다.**

<br />
<br />

## 7.5.4 적중과 부적중의 구별

불행히도, HTTP는 클라이언트에게 응답이 캐시 적중이었는지 아니면 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다. 두 경우 모두 200 OK가 될 것이다. 어떤 상용 프락시 캐시는 캐시에 어떤 일이 일어났는지 설명하기 위해 Via 헤더에 추가 정보를 붙인다.

일반적인 경우는 **Date 헤더**를 이용하는 것이다. 응답의 Date 헤더 값을 **현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있다.** 또 다른 방법은, 응답이 얼마나 오래되었는지 말해주는 **Age 헤더**를 이용하는 것이다.