# 7.9 캐시 제어

HTTP는 문서가 **만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지** 서버가 설정할 수 있는 여러 가지 방법을 정의한다.

- Cache-Control: no-store 헤더를 응답에 첨부할 수 있다.
- Cache-Control: no-cache 헤더를 응답에 첨부할 수 있다.
- Cache-Control: must-revalidate 헤더를 응답에 첨부할 수 있다.
- Cache-Control: max-age 헤더를 응답에 첨부할 수 있다.
- Expires 날짜 헤더를 응답에 첨부할 수 있다.
- 아무 만료 정보도 주지 않고, 캐시가 스스로 체험적인(휴리스틱) 방법으로 결정하게 할 수 있다.

<br />

이외에도 아래 이미지처럼 Cache-Contorl 헤더 설정 방법은 여러가지가 있다. 모든 Cache-Conrol 헤더에 대해 궁금하다면 [MDN 문서](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)를 참고해봐도 좋을 것 같다.

<img width="780" alt="스크린샷 2023-01-07 오후 2 06 48" src="https://user-images.githubusercontent.com/75570915/211132151-45da32da-5309-416a-bb77-67306e748dec.png">

<br />
<br />

### 7.9.1 no-cache와 no-store 응답 헤더

no-cache와 no-store 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다. 

```
Cache-Control: no-store
Cache-Control: no-cache
Pragma: no-cache
```

`no-store` 가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지한다. `no-store` 응답을 전달하고 나면 객체를 삭제할 것이다.

`no-cache` 로 표시된 응답은 로컬 캐시 저장소에 저장할 수 있다. 다만, 먼저 서버에서 재검사를 하지 않고서는 캐시에서 클라이언트로 제공할 수 없다. 

`Pragma: no-cache` 헤더는 HTTP/1.0+ 와의 하위호완성을 위해 HTTP/1.1에도 포함되어 있다. 그래서 HTTP/1.0 애플리케이션에 대응해야 하는 경우가 아니라면 `Cache-Control: no-cache` 헤더를 사용해야 한다.

<br />
<br />

### 7.9.2 Max-age 응답 헤더

`Cache-Control: max-age` 헤더는 신선하다고 간주되었던 문서가 **서버로부터 온 이후로 흐른 시간을 초로 나타낸 헤더다.** 또, `s-maxage` 헤더는 max-age처럼 행동하지만 공유된(공용) 캐시에만 적용된다.

```
Cache-Control: max-age=3600
Cache-Control: s-maxage=3600
```

서버는 `max-age`를 0으로 설정함으로써, 캐시가 매번 접근할 때마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.

<br />
<br />

### 7.9.3 Expires 응답 헤더

Expires 응답 헤더는 초 단위의 시간 대신 **실제 만료 날짜를 명시한다.** 

```
Expires: Sat, 07 Jan 2023, 09:00:00 KST
```

몇몇 서버는 문서를 항상 만료하기 위해, `Expires: 0` 헤더로 돌려보내지만, 이는 문법 위반이며 몇몇 소프트웨어와 문제를 일으킬 수 있다.

<br />
<br />

### 7.9.4 Must-Revalidate 응답 헤더

만약 캐시가 **만료 정보를 엄격하게 따르길 원한다면** 원 서버는 다음과 같은 헤더를 붙일 수 있다.

```
Cache-Control: must-revalidate
```

`Cache-Control: must-revalidate` 응답 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 **최초의 재검사 없이는 제공해서는 안 됨을 의미한다.** 만약 캐시가 must-revalidate 신선도 검사를 시도했을 때 원 서버가 사용할 수 없는 상태라면, **캐시는 반드시 504 Gateway Timeout error를 반환해야 한다.**

<br />
<br />

### 7.9.5 휴리스틱 만료

만약 응답이 Cache-Control: max-age 헤더나 Expires 헤더 중 어느것도 포함하지 않고 있다면, 캐시는 경험적인 방법으로(휴리스틱, heuristic) 최대 나이를 계산할 것이다.

유명한 휴리스틱 만료 알고리즘의 하나인 **LM 인자 알고리즘** 은, 문서가 최근 변경 일시를 포함하고 있다면 사용할 수 있다. 그 로직은 다음과 같다. 

- 만약 캐시된 문서가 마지막으로 변경된 것이 상당히 예전이라면, 그것은 **아마 안정적인 문서일 것이고 갑자기 바뀔 가능성은 별로 크지 않을 것이므로,** 캐시에 더 오래 보관하고 있어도 안전하다.

- 만약 캐시된 문서가 최근에 변경되었다면, 그것은 **아마 자주 변경될 것이고,** 따라서 우리는 그것을 서버와 재검사하기 전까지 짧은 기간 동안만 캐시해야 한다.

![LM인자알고리즘](https://user-images.githubusercontent.com/75570915/211133024-91d71b25-2432-4e65-a667-1718480f1c3e.png)

<br />

캐시는 일반적으로 신선도에 대한 아무런 단서가 없는 문서에 대해 기본 신선도 유지시간을 설정한다(보통 한 시간이나 하루정도). 더 보수적인 캐시는 휴리스틱 문서들에 대해 0의 신선도 수명을 설정하여, **캐시가 클라이언트에게 데이터를 제공할 때마다 아직 신선한지 검사하도록 강제한다.**

<br />
<br />

### 7.9.6 클라이언트 신선도 제약

웹 브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜 주는 리프레시나 리로드 버튼을 갖고 있다. 이 refesh 버튼은 Cache-Control 요청 헤더가 추가된 GET 요청을 발생시켜서, **강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.**

|지시어|설명|
|----|---|
|Cache-Control: max-stale <br />Cache-Control: max-stale=s|캐시는 신선하지 않은 문서도 자유롭게 제공할 수 있다. 만약 's' 매개변수가 지정되면, 클라이언트는 만료시간이 그 매개변수의 값만큼 지닌 문서도 받아들인다. 이것은 캐싱 규칙을 느슨하게 한다.|
|Cache-Control: min-refresh=s|클라이언트는 적어도 's'초 후까지 신선한 문서만 받아들인다. 이것은 캐싱 규칙을 엄격하게 한다.|
|Cache-Control: max-age=s|캐시는 's'초보다 오랫동안 캐시된 문서를 반환할 수 없다. max-stale 지시어가 함께 설정되지 않는 이상, 캐싱 규칙을 엄격하게 한다.|
|Cache-Control: no-cache <br />Pragma: no-cache|이 클라이언트는 캐시된 리소스는 재검사하기 전까지 받아들이지 않을 것이다.|
|Cache-Control: no-store|이 캐시는 저장소에서 문서의 흔적을 최대한 빨리 삭제해야 한다. 그 문서에는 민감한 정보가 포함되어 있기 때문이다.|
|Cache-Control: only-if-cached|클라이언트는 캐시에 들어있는 사본만을 원한다.|

<br />
<br />

### 7.9.7 주의할 점

문서 만료는 완벽한 시스템이 아니다. 만약 유효기간을 까마득한 먼 미래로 설정한다면, 그 문서는 오랫동안 변경되지 않을 것이다. 심지어 유효기간을 설정하지 않아서, 문서가 오랫동안 신선할 것인지 캐시가 알기 어렵게 되는 경우도 많이 있다.







