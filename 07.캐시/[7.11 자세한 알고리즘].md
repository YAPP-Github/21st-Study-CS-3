# 7.11 자세한 알고리즘

## 1. 개요

- HTTP 명세는 문서의 나이와 캐시 신선도를 계산하는 알고리즘을 제공
- HTTP 명세에 나온 알고리즘을 설명할 때 편의상 [펄 의사코드](https://happygrammer.github.io/guide/perl/) 사용

## 2. 나이와 신선도 수명(7.11.1)

- 캐시된 문서가 제공하기에 충분히 신선한지 알려주려면, 캐시는 단 두가지 값만 계산하면 됨
  - `캐시된 사본의 나이`
  - `신선도 수명`
- 만약 `캐시된 사본의 나이가 신선도 수명보다 작으면` 사본은 제공해주기에 충분히 신선한 것
- 위의 내용을 펄로 작성한 것

```perl
$충분히_신선한가 = ($나이 < $신선도_수명);
```

- `문서의 나이`
  - 서버가 문서를 보낸(혹은 서버가 마지막으로 재검사한) 후 그 문서가 `‘나이를 먹은’` 시간의 총합
- 캐시는 문서 응답이 업스트림 캐시에서 왔는지 서버에서 왔는지 모를 수 있기 때문에, 문서가 완전히 새롭다고 가정하지 못함
  - `Age 헤더를 통해 명시적으로든(책에서 추천하는 방법) 서버가 생성한 Date 헤더를 통해 계산하든 간에` 문서의 나이를 판별해야 한다
- `문서의 신선도 수명`
  - 아직 문서가 신선하다고 볼 수 있는 수명
  - `문서의 나이가 신선도 수명을 넘었다면`, 클라이언트에게 제공해주기엔 더이상 충분히 `신선하지 않은 것`
  - 신선도 수명의 계싼에는 문서의 유효기간과 신선도에 영향을 주는 클라이언트의 모든 요청을 고려
- 어떤 클라이언트는 `약간 신선하지 않은 문서라도 받아들이려고 할 수도 있고` (Cache-Control: max-stale 헤더를 사용) 다른 클라이언트는 `조만간 신선하지 않게 될 문서조차 받아들이려 하지 않을 수 있다`(Cache-Control: min-fresh 헤더를 사용)
- 캐시는 `서버 만료 정보`와 `클라이언트 신선도 요구사항`을 조합해서 `최대 신선도 수명`을 판별

## 3. 나이 계산(7.11.2)

- `응답의 나이`
  - `응답이 서버에서 생성되었을 (혹은 서버로부터 재검사되었을) 때부터 지금까지의 총 시간`
  - 응답이 인터넷상의 라우터들과 게이트웨이들 사이를 떠돌아다닌 시간(중개 캐시에 기록되어 있음)과 응답이 캐시에 머물렀던 시간 포함
- `완전한 HTTP/1.1 나이 계산 알고리즘`

```perl
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$응답_지연_추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값;
$사본이_우리의_캐시에_머무른_시간 = $현재_시각 - $응답을_받은_시각;

$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간;
```

- 캐시는 응답이 캐시에 도착했을 때 `Date나 Age 헤더를 분석해서 얼마나 오래된 것인지` 알 수 있다
- 캐시는 또한 그 문서가 `로컬 캐시에 얼마나 오래 머물렀는지` 알 수 있다
- 이 둘을 합하면, 이 값들은 응답의 전체 나이가 된다
- HTTP 는 클록 스큐([clock skew](https://blog.naver.com/PostView.nhn?blogId=anstyle12&logNo=221017375255&parentCategoryNo=&categoryNo=21&viewDate=&isShowPopularPosts=true&from=search))와 네트워크 지연을 보상하기 위해 마법을 약간 사용하지만 기본 계산은 아래와 같다

`$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간;`

- 캐시는 `캐시된 사본이 로컬에서 얼마나 오랫동안 캐시되었는지` 쉽게 알아낼 수 있다
- 캐시에서 온 응답의 나이를 알아내는 것이 더 어려운데 `모든 서버가 동기화된 시계를 갖고 있지는 않으며 우리는 응답이 어디에서 왔는지도 모르기 때문`

→ `완전한 나이 계산 알고리즘은 이것을 바로잡으려 시도`

### 3-1. 완전한 나이 계산 알고리즘의 개요

### 1) 겉보기 나이는 Date 헤더에 기반한다

- 만약 모든 컴퓨터가 똑같이 정확한 시계를 갖고 있다면 캐시된 문서의 나이는 단순히 현재 시간에서 서버가 문서를 보낸 시간을 뺀, 문서의 `겉보기 나이` 가 될 것
  - 서버는 시간을 단순히 Date 헤더의 값으로 보냄
  - 가장 단순한 기초적 나이 계산은 그냥 겉보기 나이를 사용하는 것

```perl
$겉보기_나이 = $응답을_받은_시각 - $Date_헤더값;
$문서가_우리의_캐시에_도착했을_때의_나이 = $겉보기_나이;
```

- 불행히도 `모든 시계가 잘 동기화되지는 않음`
- 웹 애플리케이션, 특히 캐시 프락시는 `시계 값이 극단적으로 차이 나는 서버와 상호작용 하는 경우를 대비`해야 함
- 이와 같이, 두 컴퓨터의 시계 설정 차이로 인한 문제를 `클록 스큐`라 함
- 클록 스큐 때문에 겉보기 나이는 종종 `부정확`하며 때로는 `음수`가 되기도 함
  - 만약 나이가 음수가 되는 일이 있다면 다음의 펄 의사코드와 같이 우리는 바로 그것을 0으로 만들어야 함
  - 또한 겉보기 나이가 터무니없이 커지지 않도록 간단한 검사를 추가할 수도 있지만 큰 겉보기 나이가 사실은 맞는 값일수도 있다. 오랫동안 문서를 캐시하고 있는(그리고 원래의 Date 헤더를 보관하고 있는) 부모 캐시와 대화중이었을 수도 있기 때문

```perl
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$문서가_우리의_캐시에_도착했을_때의_나이 = $겉보기_나이;
```

- Date 헤더가 원래의 원 서버 날짜를 서술한다는 사실에 주의
- 프락시와 캐시는 이 날짜를 절대로 변경하면 안됨

### 2) 점층적 나이 계산

- 그래서 우리는 클록 스큐를 초래하는 음수 나이를 제거할 수 있지만 클록 스큐로 인한 정확도 손실 전반에 대해서는 별로 할 수 있는 일이 없다
- HTTP/1.1 에서 동기화된 시계라는 것이 존재하지 않는 문제에 대한 우회책
  - `문서가 프락시나 캐시를 통과할 때마다 그 장치들이 Age 헤더에 상대적인 나이를 누적해서 더하도록 함`
  - 이 방법은 서버간의 시간 비교나 종단 간의 시간 비교를 필요로 하지 않음
- Age 헤더 값은 문서가 프락시들을 통과하면서 점점 늘어남
  - HTTP/1.1을 이해하는 애플리케이션은 문서가 각 애플리케이션에 머무른 시간과 네트워크 사이를 이동한 시간만큼 Age 헤더의 값을 늘려야 함
  - 각 중간 애플리케이션은 자신의 내부 시계를 이용해서 쉽게 문서의 체류시간을 계산할 수 있음
- 그러다 응답 체인에 있는 `비-HTTP/1.1 장치는 Age 헤더를 인식하지 못하고 그 헤더를 고치지 않거나 삭제`해버림

→ 따라서 어디서나 HTTP/1.1 을 채택하는 날이 오기 전까지는 `Age 헤더는 상대 나이에 대한 모자란 추정값인 상태로 남아있을 것`

- 이 상대 나이 값은 Date 기반 나이와는 별개로 계산되어 두 나이 추정값 중 보수적인(가장 큰) 것이 선택되는데 왜냐하면 다른 서버에서 넘어온 Date 값이나 나이 계산값은 실제보다 작게 계산된 값일 수 있기 때문
- 이 방법에서 HTTP 는 더 신선한 콘텐츠를 얻을 수만 있다면 Age 헤더의 오류도 용인

```perl
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이;
```

### 3) 네트워크 지연에 대한 보상

- 트랜잭션을 느려질 수 있고 이는 캐시를 하는 주요한 동기
- 그러나 매우 느린 네트워크나 과부하가 걸린 서버에서 문서가 네트워크나 서버의 교통 혼잡에 긴 시간동안 갇혀있었던 경우 상대 나이 계산은 문서의 나이에 대한 상당히 모자란 추정이 될 수도 있다
- Date 헤더는 언제 문서가 원 서버를 떠났는지 나타내지만 `문서가 캐시로 옮겨가는 도중에 얼마나 시간을 소비했는지는 말해주지 않는다`
  - 만약 문서가 프락시들과 부모 캐시의 긴 연쇄를 거쳐서 왔다면 네트워크 지연은 상당한 수준일 것
- 서버에서 캐시로의 단방향 네트워크 지연을 측정하는 쉬운 방법은 없지만 `왕복 지연을 계산`하는 것은 상대적으로 쉬움
- 캐시는 언제 문서를 요청했고 언제 도착했는지 알고 있다
  - HTTP/1.1은 이를 이용해 계산한 `전체왕복시간을 더함`으로써 `네트워크 지연을 보수적으로 교정`
  - 캐시에서 서버로 갔다가 다시 캐시로 돌아오느라 발생한 지연은 서버에서 캐시로 가느라 발생한 지연을 보수적으로 크게 추정

```perl
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$응답_지연_추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값;
```

## 4. 완전한 나이 계산 알고리즘(7.11.3)

- HTTP로 실어 날라진 문서가 도착했을 때 그 나이를 어떻게 계산하는지 이전 절에서 보여주었다
- 이 응답이 캐시에 한 번 저장되면 나이를 더 먹게 된다
- 문서에 대한 요청이 캐시에 도착헀을 때 우리는 그 문서의 현재 나이를 계산하기 위해 그 문서가 캐시에 얼마나 오랫동안 머물렀는지 알 필요가 있다

```perl
$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간;
```

## 5. 신선도 수명 계산(7.11.4)

- 어떤 문서의 신선도 수명은 문서가 특정 클라이언트에게 제공해주기에는 더이상 신선하지 않게 될 때까지 얼마나 오랜 시간 동안 가져올 수 있도록 허용되는지 말해준다
- 신선도 수명은 `서버와 클라이언트의 제약조건`에 의존
- `서버는 문서가 얼마나 자주 변경되어 발행되는지에 대한 정보`를 갖고 있을 수도 있다
  - 매우 안정된 서류철속의 보고서는 수년 동안 신선한 상태를 유지하는 경우도 있다
  - 정기 간행물이라면 다음번 출판일전까지 남아있는 시간동안만 신간일 수도 있다
- `클라이언트는 다른 가이드라인`을 갖고 있을 수 있다
  - 그들은 속도가 더 빠르다면 약간 신선하지 못한 콘텐츠도 받아들이려 할 수도 있고 반대로 가능한 가장 최신의 콘텐츠를 요구할 수도 있다

## 6. 완전한 서버 신선도 알고리즘(7.11.5)

- `서버 신선도 한계`를 계산하는 펄 알고리즘
- 문서가 여전히 서버에서 제공되는 상황에서 도달할 수 있는 최대 나이 반환

```perl
sub 서버_신선도_한계 {
  local($휴리스틱, $서버_신선도_한계, $마지막으로_변경된_시각)

  $휴리스틱 = 0;
  if ($Max_Age_값이_설정되었나) {
		$서버_신선도_한계 = $Max_Age_값
	}
  elsif ($Expires_값이설정되었나) {
		$서버_신선도_한계 = $Expires_값 - $Date_값
	}
  elsif ($Last_Modified_값이_설정되었나) {
    $마지막으로_변경된_시각 = max(0, $Date_값 - $Last_Modified_값)
    $서버_신선도_한계 = int($마지막으로_변경된_시각 * $lm_인자);
    $휴리스틱 = 1;
  } else {
    $서버_신선도_한계 = $캐시_최소_수명_기본값;
    $휴리스틱 = 1;
  }

  if ($휴리스틱) {
    if ($서버_신선도_한계 > $캐시_최대_수명_기본값) $서버_신선도_한계 = $캐시_최대_수명_기본값
    if ($서버_신선도_한계 < $캐시_최소_수명_기본값) $서버_신선도_한계 = $캐시_최소_수명_기본값
  }
  return $서버_신선도_한계
}
```

- `서버 신선도 한계를 가져와서 클라이언트의 제약에 맞게 수정`하는 예
- 문서가 도달할 수 있고 재검사없이 캐시로부터 제공될 수 있는 최대 나이 반환

```perl
sub 클라이언트가_수정한_신선도_한계 {
	$나이_한계 = 서버_신선도_한계()

	if ($Max_Stale_값이_설정되었나) {
	  if ($Max_Stale_값 == $INT_MAX) { $나이_한계 = $INT_MAX }
	  else { $나이_한계 = 서버_신선도_한계() + $Max_Stale_값 }
	}
	if ($Min_Fresh_값이_설정되었나) {
	  $나이_한계 = min($나이_한계, 서버_신선도_한계() - $Min_Fresh_값)
	}
	if ($Max_Age_값이_설정되었나) { $나이_한계 = min($나이_한계, $Max_Age_값) }
  }
```

- 전체 과정은 문서의 나이와 신선도 한계라는 두 가지 변수가 관련되어 있다
- 만약 나이가 신선도 한계보다 작다면 문서는 충분히 신선하다
