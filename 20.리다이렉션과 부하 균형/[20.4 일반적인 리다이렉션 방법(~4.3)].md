# 20.4 일반적인 리다이렉션 방법

## 1. HTTP 리다이렉션(20.4.1)

- 웹 서버들은 다른 곳에 요청을 보내보라고 말해주는 짧은 리다이렉트 메시지를 클라이언트에게 돌려줄 수 있다
- 몇몇 웹 사이트는 HTTP 리다이렉션을 이용해 간단하게 부하를 분산한다
- 요청을 처리하는 서버(리다이렉팅 서버)는 가용한 것들 중 부하가 가장 적은 콘텐츠 서버를 찾아서 브라우저의 요청을 그 서버로 리다이렉트한다
- `웹 서버들이 광범위하게 분산되어 있다면 최선의 가용한 서버를 결정하는 것은 더욱 어려워진다`
- 서버의 부하뿐 아니라 `인터넷상에서의 브라우저와 서버간의 거리도 계산에 넣어야 하기 때문`이다
- 다른 형태의 리다이렉션에 비해 HTTP 리다이렉션이 갖는 장점 중 하나는 `리다이렉트를 하는 서버가 클라이언트의 아이피 주소를 안다는 것`이다
- 이론적으로 이렇게 하면 좀 더 정보에 근거해 선택할 수 있다
- 다음은 HTTP 리다이렉션이 어떻게 동작하는지 보여준다.
- 예를 들어, 앨리스가 `www.joes-hardware.com에 요청을 보낸다`
  ```bash
  GET /hammers.html HTTP/1.0
  Host: www.joes-hardware.com
  User-Agent: Mozilla/4.51 [en] (X11; U; IRIX 6.2 IP22)
  ```
  - 서버는 HTTP 상태코드 200과 함께 웹페이지의 본문을 돌려주는 대신, `상태코드 302와 함께 리다이렉트 메시지를 돌려보내주었다.`
  ```bash
  HTTP/1.0 302 Redirect
  Server: Stronghold/2.4.2 Apache/1.3.6
  Location: http://161.58.228.45/hammers.html
  ```
  - 이제 그럼 브라우저는 `호스트를 161.58.228.45 로 하여 리다이렉트 URL 을 사용한 다음과 같은 요청을 다시 보낸다`
  ```bash
  GET /hammers.html HTTP/1.0
  Host: 161.58.228.45
  User-Agent: Mozilla/4.51 [en] (X11; U; IRIX 6.2 IP22)
  ```
  - 이외 또 다른 클라이언트는 다른 서버로 리다이렉트 될 수도 있다. 예를 들면 밥이 똑같이 www.joes-hardware.com로 똑같은 요청을 보내면 161.58.228.46으로 리다이렉트 될 수 있다.
- HTTP 리다이렉션은 서버로 향하는 요청의 방향을 변경할 수 있지만 다음과 같은 몇가지 단점이 있다
  - 어떤 서버로 리다이렉트할지 결정하려면 원 서버는 상당히 많은 처리를 해야한다. 때로는 거의 페이지 자체를 제공할 때 필요한 것과 거의 같은 양의 처리가 필요하다
  - 페이지에 접근할 때마다 두 번의 왕복이 필요하기 때문에, 사용자가 더 오래 기다리게 된다
  - 만약 리다이렉트 서버가 고장 나면 사이트도 고장난다
- 이런 약점들 때문에 HTTP 리다이렉션은 보통 몇몇 다른 리다이렉션 기법과 함께 조합하여 사용한다

## 2. DNS 리다이렉션(20.4.2)

- 클라이언트가 죠의 하드웨어 웹 사이트에 접근하려고 시도할 때마다 도메인 이름 [www.joes-hardware.com](http://www.joes-hardware.com) 은 반드시 아이피 주소로 분석되어야 한다
- DNS 분석자는 클라이언트의 운영체제일 수도 있고 클라이언트의 네트워크에 있는 DNS 서버이거나 혹은 더 원격에 있는 DNS 서버일 수도 있다
- DNS 는 하나의 도메인에 여러 아이피 주소가 결부되는 것을 허용하며 DNS 분석자는 여러 아이피 주소를 반환하도록 설정되거나 프로그래밍 될 수 있다
- 분석자가 어떤 아이피 주소를 반환할 것인가를 결정하는 방법은 단순한 것(라운드 로빈)부터 복잡한 것(여러 서버의 로드를 검사해서 로드가 가장 적은 서버의 아이피 주소를 반환하는 것)까지 다양하다
- 예를 들어 죠가 [www.joes-hardware.com](http://www.joes-hardware.com)를 위해 4대의 서버를 운영한다고 가정한다면, DNS 서버는 www.joes-hardware.com 에 대해 네 개의 아이피 주소 중에서 어떤 것을 돌려줄지 결저해야 한다. 가장 쉬운 DNS 결정 알고리즘은 단순한 라운드 로빈이다

### DNS 라운드 로빈

- DNS 라운드 로빈은 `웹 서버 팜 전체에 대한 부하의 균형을 유지하기 위해 DNS 호스트 명 분석 기능을 사용한다`
- 이것은 순수한 부하 균형 전략이며 서버에 대한 클라이언트의 상대적인 위치나 서버의 현재 스트레스를 고려하지 않는다

### 다중 주소와 라운드 로빈 주소 순환

- 대부분의 DNS 클라이언트는 그냥 `다중 주소 집합의 첫 번째 주소를 사용`한다
- 부하 균형을 위해 대부분의 DNS 서버는 룩업이 끝났을 때마다 주소를 순환시킨다
- 이 주소 순환을 `DNS 라운드 로빈`이라 부르기도 한다
- 예를 들어 [www.cnn.com](http://www.cnn.com) 에 대해 세번 연속으로 DNS 룩업을 하면 IP 주소들의 목록을 세 번 순환한 결과를 얻게 된다
  ```bash
  % nslookup www.cnn.com
  Name: cnn.com
  Addresses: 207.25.71.5, 207.25.71.6, 207.25.71.7, 207.25.71.8
  207.25.71.9, 207.25.71.12, 207.25.71.20, ....

  % nslookup www.cnn.com
  Name: cnn.com
  Addresses:  207.25.71.6, 207.25.71.7, 207.25.71.8, 207.25.71.9
  207.25.71.12, 207.25.71.20, .... , 207.25.71.5

  % nslookup www.cnn.com
  Name: cnn.com
  Addresses:  207.25.71.7, 207.25.71.8, 207.25.71.9, 207.25.71.12
  207.25.71.20, .... , 207.25.71.5, 207.25.71.6
  ```
  - 첫번째 DNS 룩업의 첫 번째 주소는 207.25.71.5 이다
  - 두번째 DNS 룩업의 첫 번째 주소는 207.25.71.6 이다
  - 세번째 DNS 룩업의 첫 번째 주소는 207.25.71.7 이다

### 부하 균형을 위한 DNS 라운드 로빈

- 대부분의 DNS 클라이언트는 그냥 첫 번째 주소를 사용하기 때문에 DNS 순환은 서버들 간의 부하 균형을 유지해준다
- 만약 DNS 가 주소를 순환시키지 않는다면 대부분의 클라이언트가 목록의 첫번째 서버를 선택할 것이고 그 서버가 대부분의 부하를 받게 될 것이다
- 예) 앨리스가 [www.cnn.com](http://www.cnn.com) 에 접속하려 시도할 때 그녀는 DNS 를 이용해 IP 주소를 찾아보고 207.25.71.5 를 첫번째 아이피 주소로 돌려받는다. 앨리스는 웹 서버 207.25.71.5에 접속한다
- 계속해서 밥이 [www.cnn.com](http://www.cnn.com) 에 접속하려 시도할 때 그 또한 DNS 를 이용해 IP 주소를 찾아보는데 이때 그는 다른 결과를 돌려받게 된다. 왜냐하면 앨리스의 이전 요청에 의해 주소 목록이 한 차례 순환되었기 때문이다. 밥은 207.25.71.6 을 첫번째 아이피 주소로 돌려받고 이 서버에 접속한다.

### DNS 캐싱의 효과

- DNS 주소 순환은 부하를 순환시킨다
  - 서버에 대한 각 DNS 룩업은 서버 주소를 다른 순서로 가져오기 때문이다
- 그러나 이 부하 균형은 완벽하지 않은데 `DNS 룩업의 결과는 애플리케이션, 운영체제, 몇몇 기초적인 자식 DNS 서버에 의해 기억되어 재사용될 수 있기 때문`이다
- 호스트 하나에 대해 한 번의 DNS 룩업을 수행한 뒤 그 주소를 몇번이고 다시 사용한다
- 그렇게 하면 DNS 룩업의 비용을 줄일 수 있을 뿐 아니라 같은 클라이언트와 계속 대화하는 것을 선호하는 서버들도 있기 때문이다
- 이러한 이유로 DNS 라운드 로빈은 일반적으로 하나의 클라이언트로 인한 부하를 제대로 분산하지 못한다
- 클라이언트는 보통 같은 서버에 꽤 오랫동안 매어있게 될 것이다
- 그러나 비록 DNS 가 단일 클라이언트의 트랜잭션을 서버의 복제들에게 나눠주지는 않더라도 그것은 여러 클라이언트들의 부하 총량을 분산하는 적절한 작업을 수행한다
- 비슷한 요청을 하는 클라이언트의 수가 어느 정도 이상만 된다면 부하는 모든 서버에 걸쳐 상대적으로 잘 분산될 것이다

### 다른 DNS 기반 리다이렉션 알고리즘

- 몇몇 향상된 DNS 서버는 주소의 순서를 결정하기 위해 다른 기법들을 사용한다

1. `부하 균형 알고리즘`

- 몇몇 DNS 서버는 웹 서버의 로드를 추적하고 가장 로드가 적은 웹 서버를 목록의 가장 위에 놓는다

1. `근접 라우팅 알고리즘`

- 웹 서버들의 팜이 지리적으로 분산되어 있는 경우, DNS 서버는 사용자를 근처의 웹 서버로 보내는 시도를 할 수 있다

1. `결함 마스킹 알고리즘`

- DNS 서버는 네트워크의 건강 상태를 모니터링하고 요청을 정전이나 기타 장애를 피해서 라우팅 할 수 있다

## 3. 임의 캐스트 어드레싱(20.4.3)

- 임의 캐스트 어드레싱에서 여러 지리적으로 흩어진 웹 서버들은 정확히 같은 아이피 주소를 갖고 클라이언트의 요청을 클라이언트에서 가장 가까운 서버로 보내주기 위해 백본 라우터의 `‘최단거리’` 라우팅 능력에 의지한다
- 이 방법이 동작하는 방식 중 하나는 `각 웹 서버에게 자신을 인접한 백본 라우터를 향하는 라우터라고 광고`하는 것이다
- 웹 서버는 라우터 통신 프로토콜을 이용해 자신과 인접한 백본 라우터와 대화한다
- 백본 라우터가 임의 캐스트 주소를 목적지로 하는 패킷을 받았을 때 그것은 그 아이피 주소를 받아들일 수 있는 가장 가까운 `‘라우터’`를 찾는다
- 그 서버는 자신이 그 주소를 위한 라우터라고 광고한 상태일 것이기 때문에 그 백본 라우터는 그 서버에게 그 패킷을 보낼 것이다
- 예) 세 서버가 같은 아이피 주소 10.10.10.1 을 향하고 있다
  - 로스엔젤레스 서버(LA)는 이 주소를 LA 라우터에게 광고했으며 뉴욕(NY) 서버는 같은 주소를 NY 라우터에게 광고했고 나머지들도 이런 식으로 했다
  - 서버는 라우터와 라우터 프로토콜을 사용해서 통신한다
  - 라우터는 10.10.10.1 을 향한 클라이언트의 요청을 자동으로 그 주소를 광고한 가장 가까운 서버로 라우팅한다
- 임의 캐스트 어드레싱은 여전히 실험적인 기법이다
- 분산 임의 캐스트의 동작을 위해 서버는 반드시 ‘라우터의 언어로 말해야 하고’ 라우터는 일어날 수 있는 주소 충돌을 반드시 다룰 수 있어야 한다
- 분산 임의 캐스트는 최근에 만들어진 기술이며 그들 자신의 백본 네트어크를 제어하는 콘텐츠 제공자들을 위한 솔루션이 될 수 있다
