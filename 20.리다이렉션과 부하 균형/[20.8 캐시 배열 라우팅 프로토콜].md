# 20.8 캐시 배열 라우팅 프로토콜

- `프락시 서버`는 `사용자 개개인으로부터의 요청을 가로채어 요청한 웹 객체의 캐시된 사본을 제공함으로써 인터넷으로 향하는 트래픽을 대폭 줄여준다`
  - 그러나 사용자의 증가에 따라 대량의 트래픽은 프락시 서버 자체에 과도한 부하를 줄 수 있다
- 이 문제에 대한 해결책 중 하나는 `부하를 분산하기 위해 사용하는 프락시 서버를 여러 대로 늘리는 것`이다
- `캐시 배열 라우팅 프로토콜( CARP)`은 프락시 서버의 배열이 클라이언트의 시점에서는 마치 하나의 논리적인 캐시처럼 보이도록 관리해주는, 마이크로소프트와 넷스케이프 커뮤니케이션이 제안한 표준이다
- CARP는 `ICP의 대안`
  - CARP와 ICP 둘 다 관리자가 여러 대의 프락시 서버를 사용하여 성능을 개선할 수 있게 해준다
  - 이 점은 어떻게 CARP가 ICP와 다른지, CARP를 사용하는 것이 ICP에 비해 어떤 장점과 단점이 있는지, 그리고 CARP 프로토콜을 어떻게 구현하는지에 대한 기술적인 세부사항에 대해 논한다
- ICP에서 `캐시 비적중이 발생하면 프락시 서버은 웹 객체의 가용성을 판단하기 위해 이웃 캐시들에게 ICP메시지 포맷을 사용해서 질의를 보낸다`
  - 이웃의 캐시들은 `HIT`나 `MISS` 로 응답하고 요청한 프락시 서버는 이 응답을 이용해서 객체를 받아올 가장 적절한 위치를 선택한다
  - 만약 ICP 프락시 서버들이 계층적으로 구성되어 있다면, 비중은 부모에게 상향 전파된다.
  - ICP 프로토콜로 서로 연결된 프락시 서버들 각각은 콘텐츠의 쓸데없는 복제본도 갖고 있는, 다시 말해 `프락시 서버들 전체에 걸친 웹 객체에 대한 중복된 엔트리가 허용되는 독립적인 캐시임에 주목`하라
  - 대조적으로 CARP 를 이용해서 독자적으로 동작하는 서버들의 무리는, `각 구성요소 서버가 전체 캐시된 문서의 일부만 갖고 있는 하나의 큰 서버처럼 동작`한다
- 웹 객체의 URL에 해시 함수를 적용함으로써 CARP 는 `웹 객체를 특정 프락시 서버에 매핑`한다
- 하나의 웹 객체는 하나의 프락시 서버에만 속하기 때문에 프락시 서버 각각을 폴링하지 않고도 한 번의 검색으로 그 객체의 위치를 결정할 수 있다
- CARP 에서 프락시 서버 분석이 결정론적이라는 것은 질의를 `모든 이웃에게 보낼 필요는 없다는 뜻`이고 이는 `캐시가 주고받아야 하는 메시지가 더 적음`을 의미한다
- 더 많은 프락시 서버가 설정에 추가됨에 따라 그 집단 캐시 시스템은 상당히 괜찮게 확장될 것이다
- 그러나 CARP는 `프락시 서버 중 하나가 사용할 수 없게 되면 이 사실을 반영하기 위해 해시 함수가 수정되어야 하고 프락시 서버 전체에 퍼져있는 콘텐츠들도 다시 배치하지 않을 수 없다는 단점`이 있다
- 프락시 서버의 고장이 잦다면 이로 인한 비용은 상당히 비쌀 수 있다
- 반면 `ICP 프락시 서버들에는 콘텐츠가 중복되어 존재하므로 다시 배치할 필요가 없다`
- 또 하나의 잠재적인 문제점은 CARP 는 새로운 프로토콜이기 때문에 `ICP 프로토콜만을 수행하는 기존 프락시 서버는 CARP 무리에 쉽게 포함될 수 없을 것이라는 점`이다
- CARP 와 ICP의 차이점을 설명하기 위해 CARP 를 조금 더 자세히 서술하겠다. `CARP 리다이렉션 방법`은 다음의 작업을 포함한다
  - 참여하는 프락시 서버의 테이블을 유지한다. 이 프락시 서버들은 각각이 살아 있는지 알아보기 위해 주기적으로 폴링된다
  - 각 참여 프락시 서버들에 대해 해시 함수를 계산한다. 해시 함수가 반환하는 값은 이 프락시가 처리할 수 있늡 부하의 양을 계산에 넣는다
  - 요청된 웹 객체의 URL에 근거한 숫자값을 반환하는 분리된 해시함수를 정의한다
  - URL의 해시 함수와 프락시 서버의 해시 함수의 합계로 값의 배열을 얻는다. 이 값들에 대한 최댓값이 그 URL을 위해 사용할 프락시 서버를 결정한다. 계산값이 결정적이기 때문에 같은 웹 객체에 대한 뒤이은 요청은 같은 프락시 서버로 포워딩될 것이다.
  - 이들 네 개의 작업은 `플러그인을 통해 브라우저에 의해 수행될 수도 있고 중간 서버에 의해 계산될 수도 있다`
- 프락시 서버들의 각 무리는 그 무리의 모든 서버를 나열하는 테이블을 생성한다
  - 테이블의 각 엔트리는 `부하 인자에 대한 정보, 생존시간(time-to-live, TTL)카운트다운 값, 구성원들이 얼마나 자주 폴링되어야 하는지에` 등에 대한 전역 매개변수를 포함해야 한다
- 부하 인자는 `장비가 얼마나 큰 부하를 다룰 수 있는지 명시`한다
  - 그 테이블은 RPC인터페이스를 통해 원격으로 관리될 수 있다
- 일단 테이블의 필드들이 RPC에 의해 갱신되면 그 필드들은 사용할 수 있게 되거나 혹은 다운스트림의 클라잉너트들에게 배포된다
  - 이 배포는 HTTP 에 의해 수행되므로 어떤 클라이언트나 프락시 서버도 다른 프락시 프로토콜을 도입할 필요없이 그 테이블의 정보를 사용할 수 있다
  - 클라이언트와 프락시 서버는 테이블을 가져오기 위해 단순히 잘 알려진 URL을 사용한다
- 이 사용된 해시함수는 웹 객체가 참여하는 프락시 서버들 전체에 걸쳐 정적으로 분산되었음을 반드시 보장해야 한다
- 프락시 서버의 부하 인자는 그 프락시에 할당된 웹 객체의 통계적 확률을 결정하기 위해 사용되어야 한다
- `요약하면 CARP 프로토콜은 협력은 하지만 분산된 캐시가 되는 ICP와는 달리 프락시 서버 그룹을 하나의 캐시 집단으로 보이게 해준다`
- 결정론적인 요청 분석 경로는 한 홉 안에 있는 특정 웹 객체의 거처를 찾아낸다
  - 이것은 ICP에서 프락시 서버의 그룹 안에 있는 웹 객체를 찾아내기 윟 ㅐ자주 생성되는 프락시 간 트래픽을 제거한다
  - CARP는 또한 중복된 웹 캐시에 대한 사본의 중복을 피하게 되는 이로 인해 캐시 시스템이 집합적으로 웹 객체를 더 많이 보관할 수 있다는 장점이 있는 반면 어느 하나의 프락시가 실패하더라도 상당량의 캐시 콘텐츠를 재배치해야 한다는 단점도 있다
