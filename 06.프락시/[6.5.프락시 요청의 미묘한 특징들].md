# 프락시 요청의 미묘한 특징들

## 프락시 URI는 서버 URI와 다르다.

웹 서버와 웹 프락시의 메시지 문법은 같지만, 클라이언트가 프락시로 요청을 보낼 때와 서버로 요청을 보낼 때의 URI는 다르다.
| | 웹 서버로 보낼 때 | 프락시로 보낼 때 |
| --- | --- | --- |
| URI특징 | 스킴, 호스트, 포트번호가 없는 부분 URI를 갖는다. | 스킴, 호스트, 포트번호 등을 포함한 완전한 URI를 갖는다 |
| URI특징이 나타난 이유 | 단일서버는 자신의 호스트명과 포트번호를 알고있기에 불필요한 정보발송을 피하고자 다음 정보들을 보내지 않아도 됐다. | 프락시는 목적지 서버와 커넥션을 맺어야 하기 대문에 서버의 이름을 알 필요가 있다.<br> 프락시 기반 게이트웨이는 FTP리소스나 혹은 그 외의 스킴과 연결하기 위해 URI의 스킴을 알 필요가 있었다. |
| URI 예시 | GET /index/html HTTP/1.0<br> User-Agent : SuuperBrowserv1.3 | GET http://www.marys-antiques.com/index.html HTTP/1.0 <br> User-Agent : SuuperBrowserv1.3 |
| 언제 적용되는가? | 클라이언트가 프락시를 사용하지 않도록 설정되어있을 때 | 클라이언트가 프락시를 사용하도록 설정되어있을 때 |
<br><br><br>

## 웹 서버가 부분 URI를 보내며 발생하는 문제(부분 URI 사용으로 발생하는 프락시 종류 별 문제)

가상으로 호스팅되는 웹서버가 직면한 문제와 동일하다. 그러나 해결 법은 다르다.<br>
→ **명시적 프락시 :** 요청메시지가 **완전한 URI**를 갖도록 함.<br>
→ **가상 호스팅되는 웹 서버 :** 호스트와 포트에 대한 정보가 담긴 **Host헤더**를 요구<br>

### [여기서 의문]

<i>클라이언트에겐 보이지 않는 **대리 프락시**와 **인터셉트 프락시**는 부분 URI를 받을텐데 이 경우엔 어떻게 해결하는가?</i>

##### 대리 프락시 :

대리 프락시는 원 서버의 호스트명과 아이피 주소를 사용해 원 서버를 대신하는 프락시이기에 실제 서버 주소와 포트번호가 설정되어 있을 수 있다. 이를 이용하여 요청을 한다.

##### 인터셉트 프락시 :

만약 웹 서버의 IP 주소와 포트번호가 사용가능하도록 설정된 인터셉트 프락시라면 이를 활용해 요청을 한다.

##### 이 모든 경우를 벗어난다면?

에러메시지(주로 Host 헤더를 지원하는 브라우저로 업그레이드하라는 메시지)를 반환한다.

### 정리하면,

```
if(inputURI == 완전URI) {
    return inputURI
} else if(inputURI == 부분URI && 헤더.includes(Host헤더)) {
    // 호스트 헤더로 원래 서버명과 포트번호를 알아낸다.
} else if(프락시.type == 대리_프락시){
    // 프락시에 실제 서버 주소와 포트번호가 설정되어있는지 확인하여 이를 사용해 알아낸다.
} else if(프락시.type == 인터셉트_프락시 && 원래 IP주소와 포트번호를 사용할 수 있는지 확인){
    // 원래 IP주소와 포트번호를 사용할 수 있는지 확인하여 가능하다면 이를 사용
} else {
    // 에러 메시지(주로 Host헤더를 지원하는 브라우저로 업그레이드하라는 요청이 담긴 메시지)를 반환
}
```

<br><br><br>

## 전송 중 URI가 변경되며 발생하는 문제(URI 정규화로 발생하는 문제)

- 프락시 서버는 무해해보이는 사소한 URI의 변경으로도 다운스트림 서버와 상호운용성 문제를 일으킬 수 있다.
- 특히 다음 홉으로 보내기 전에 정규화를 하는 프락시의 경우에서 주의해야한다

  ```
  Ex. HTTP포트를 명시적인 :80으로 변경하기
  Ex. 잘못 사용한 예약된 글자를 올바르게 이스케이프하여 교체하기
  ```

- 일반적으로 프락시 서버는 가능한 한 관대하도록 애써야하며 프로토콜을 엄격하게 준수하도록 강제하는 `프로토콜 경찰`처럼 되려고 해서는 안된다.
- 특히 http명세는 일반적인 인터셉트 프락시가 URI를 전달할 때 `절대 경로를 고쳐쓰는 것을 금지`한다. 유일한 예외는 빈 경로를 `/`으로 교체하는 것 뿐이다.

<br><br><br>

## URI분석

### 클라이언트 자동확장과 호스트명 분석

#### 프락시가 없을 경우 :

타이핑한 URI를 가지고 그에 대응하는 IP주소를 찾는다.

- if(호스트명 발견) : 그에 대응하는 IP주소들을 연결에 성공할 때까지 시도
- else : 사용자가 호스트명의 짧은 약어를 타이핑한 것으로 간주하고 `자동화된 호스트명의 확장`을 제공하고자 시도

  ##### 자동화된 호스트명의 확장 방법

  - 일반적인 웹 사이트 이름의 가운데 부분만 입력했다면 접두사 (www)와 접미사(.com)을 붙인다.
  - 해석불가능한 URI를 서드파티로 넘겨 오타교정을 시도해 사용자가 의도했을 URI를 제시
  - 대부분의 시스템에서 DNS는 호스트명의 앞글자만 입력되어도 자동으로 도메인을 검색

  ##### 자동화된 호스트명의 확장 과정

  1. 사용자가 URI 창에 `oreilly`를 입력
  2. 브라우저는 `oreilly`를 호스트명으로 사용하여 기본 스킴을 `http://`, 기본 포트를 `80`, 기본 경로를 `/`으로 간주
  3. DNS를 통해 `oreilly`를 검색
  4. 호스트명 `oreilly`를 `www.oreilly.com`로 자동 확장한 뒤, 주소분해를 요청
  5. **IP주소 목록**를 반환받음
  6. 받은 IP주소들에 대해 성공할 때까지 하나씩 접속을 시도
  7. 커넥션이 맺어지면 HTTP요청을 주고 응답을 받는 과정을 진행 (성공)
     // 그림6-16넣을 것.

#### 명시적인 프락시의 경우 :

- 브라우저의 URI가 프락시를 그냥 지나쳐버리기에 **자동확장이 이뤄지지 않는다.**
  // 그림6-17넣을 것.
- 인터셉트 프락시와 마찬가지로 죽은 서버의 DNS분석에 대한 장애 허용을 지원해야한다.
  - 명시적인 프락시를 사용하도록 설정되어 있는 경우의 장애 허용은 프락시에 달려있기 때문이다.

#### 인터셉트 프락시의 경우 :

- 명시적 프락시와 마찬가지로 죽은 서버의 DNS분석에 대한 장애 허용을 지원해야한다.

1. 사용자가 URI 창에 `oreilly`를 입력
2. 브라우저는 `oreilly`를 호스트명으로 사용하여 기본 스킴을 `http://`, 기본 포트를 `80`, 기본 경로를 `/`으로 간주
3. DNS를 통해 `oreilly`를 검색
4. 호스트명 `oreilly`를 `www.oreilly.com`로 자동 확장한 뒤, 주소분해를 요청
5. **IP주소 목록**을 반환받음
6. 받은 IP주소들에 대해 성공할 때까지 하나씩 접속을 시도

   - 클라이언트는 모든 IP주소에 대해 접속을 시도하지만 어떤 IP주소들은 죽은 것일 수 있다.
   - 그러나 인터셉트 프락시를 사용하고 있다면 첫 접속 시도는 원 서버가 아닌 프락시 서버에 의해 종료되며 웹 서버는 살아있지도 않은 상태일지라도 클라이언트는 성공적으로 웹 서버와 대화했다고 믿게 된다.

7. 프락시가 최종적으로 진짜 원 서버와 상호작용할 준비가 되었다면, 프락시는 그 IP주소가 실제로는 다운된 서버를 가리키고 있음을 알고 브라우저에서 제공하는 것과 동등한 수준의 장애 허용(fault tolerance)를 제공하고자 호스트 헤더에 들어있는 호스트명을 다시 분석하거나 IP주소에 대한 역방향 DNS 룩업을 시도하여 다른 IP주소를 시도한다.
