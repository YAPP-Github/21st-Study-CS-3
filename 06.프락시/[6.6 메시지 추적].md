## 메시지 추적

클라이언트에서 서버로 향할 때 둘 이상의 프락시를 지나가게 됨

### Via 헤더

- 메시지가 노드(프락시, 게이트 웨이)를 지날 때마다 정보를 끝에 나열
  - `Via : 1.1 proxy-62.net, 1.0 cache.joes-hardware.com`
  - 2개의 프록시를 지나갔음을 알려준다
  - Via 헤더를 통한 라우팅 루프 탐지
``` 
라우팅 루프? 
패킷이 목적지를 찾지 못하고 끊임없이 순환하는 현상. 2개 이상의 라우터들이 동일 목적지 네트워크 경로에 대해 부정확한 정보를 가질 때 발생.
이를 탐지하기 위해 프락시는 요청을 보내기 전에 자신을 가리키는 unique한 문자열을 via 헤더에 삽입하고 이 문자열로 들어온 요청이 있는지를 검사한다.
```

#### Via 문법

- 쉼표로 구분
- 프로토콜 이름. 프로토콜 버전, 노드 이름, 노드 코멘트
  - 프로토콜 이름: 기본 HTTP
  - 프로토콜 버전: 사용하고 있는 프로토콜의 버전
  - 노드 이름 : 호스트와 포트 번호
  - 노드 코멘트 : 간단한 진단 정보 등을 포함(선택)
#### Via 요청과 응답 경로
![image](https://user-images.githubusercontent.com/101736358/208665786-a6b54308-a1a9-4b64-9341-0d3954fc58f0.png)

- 요청 Via 헤더 : A-> B -> C
- 응답 Via 헤더 : C -> B -> A

#### Via 와 게이트웨이
![image](https://user-images.githubusercontent.com/101736358/208666580-cdf13848-4004-4040-a59f-8e0e3d67fb89.png)

- 비 HTTP 프로토콜을 사용하는 게이트웨이의 기능을 제공하는 프락시도 존재
- 클라이언트 -> 프락시 (HTTP)
- 프락시 -> 서버 (FTP)

#### Via가 개인정보 보호와 보안에 미치는 영향
- 프락시 서버가 네트워크 방화벽의 일부인 경우 프락시는 방화벽 뒤에 숨어있는 호스트의 이름과 포트를 전달해서는 안 된다
- 일부 호스트 명 가명
- 하나의 조직 내에서 관리되는 것이라면 아래와 같이 생략 가능
- `Via: 1.0 foo, 1.1 devirus.company.com, 1.1 access-logger.company.com`
- `Via: 1.0 foo, 1.1 concealed-stu`

### Trace 메소드
- 프락시를 지나가는 과정에서 메시지가 바뀜
- HTTP 메소드 중 하나의 `Trace` 프락시의 연쇄를 따라가면서 어떤 프락시를 지나가고 어떻게 각 프락시가 요청 메시지를 수정하는지 관찰/추적
- 서버는 HTTP 응답 메시지의 본문에 포함시켜 지나온 프록시에 대한 정보를 담음 (Content-type : `message/http`)
![image](https://user-images.githubusercontent.com/101736358/208673953-6863b2a8-31b4-4c07-8d22-6b13c55b5cfb.png)

#### Max-Forward 헤더
- `TRACE`와 `OPTIONS` 요청의 프락시 홉 개수를 제한하기 위함
- 무한 루프에 빠지지 않게 테스트를 할 때
- `Max-Forward:0` : `TRACE 메시지를 더 이상 전달하지 말고 반드시 클라이언트에게 돌려줘야 한다.`
- 0보다 큰 경우 : 전달될 때마다 1씩 감소