# 13.2 요약 계산

다이제스트 인증의 핵심은 **공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 요약이다.**

## 13.2.1 요약 알고리즘 입력 데이터

d는 데이터, s는 secret을 뜻한다.

- 단방향 해시 함수 H(d) 와 요약 함수 KD(s, d).
- 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리(A1).
- 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리(A2).

A1, A2 두 조각의 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리된다.

<br />
<br />

## 13.2.2 H(d)와 KD(s, d) 알고리즘

[RFC 2617](https://www.rfc-editor.org/rfc/rfc2617)에서 제안된 두 알고리즘은 MD5와 MD5-sess('sess'는 세션을 뜻함)이며, 만약 알고리즘이 정해지지 않았다면 MD5가 기본값이다.

MD5와 MD5-sess 중 어느 것을 사용해도 H 함수는 MD5를 사용하고, KD는 콜론으로 연결된 비밀 데이터와 MD5를 계산한다. 즉, 다음과 같다.

```
H(<데이터>) = MD5(<데이터>)
KD(<Secret>, <데이터>) = H(연결(<Secret>:<데이터>))
```

<br />
<br />

## 13.2.3 보안 관련 데이터(A1)

A1으로 불리는 데이터 덩어리는 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이루어져 있다. **A1은 메시지 자체가 아닌 비밀 정보와 관련되어 있다.** 그리고 A1을 계산할 수 있는 두 알고리즘은 다음과 같다.

**MD5**

모든 요청마다 단방향 해시를 실행한다.

**MD5-sess**

사용자 이름, 영역, 비밀번호에 대한 해시를 계산한 결과 뒤에 현재 난스와 클라이언트 난스(c)를 붙인 것이 A1이 된다. [GPU를 많이 사용하는 해시 계산](https://koreascience.kr/article/CFKO202133649120992.pdf)은 처음 WWW-Authenticate 핸드셰이크를 할 때 단 한번만 수행한다.

<br />
<br />

## 13.2.4 메시지 관련 데이터(A2)

A2는 URL, 요청 메서드, 메시지 엔터티 본문과 같은 메시지 자체의 정보를 나타낸다. **A2는 메서드, 리소스, 메시지의 위조를 방지하기 위해 사용된다.** RFC 2617은 선택된 보호 수준(quality of protection, qop)에 따른 A2의 두 가지 사용법을 정의하고 있다.

- HTTP 요청 메서드와 URL만 포함하는 것이다. 이것은 기본값이기도 한 qop="auth"일 때 사용된다.
- 두 번째 방법은 메시지 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가하는 것이다. 이것은 qop="auth-int"일 때 사용된다.

<br />

<img width="400px" alt="13-1" src="https://user-images.githubusercontent.com/75570915/222966135-13fe20a6-61e8-45b0-b43d-e317a3d3a926.png">

- request-method(요청 메서드) - HTTP 요청 메서드.
- uri-directive-value(uri 지시자 값) - 요청줄에서 가져온 요청 URI.
- \*, absoluteURL, abs_path 중 아무거나 될 수 있지만 반드시 요청 URI와 일치해야 한다.
  요청 URI가 absoluteURL이라면 uri-directive-value도 반드시 absoluteURL이어야 한다.

<br />
<br />

## 13.2.5 요약 알고리즘 전반

RFC 2617은 H, KD, A1, A2로 요약을 계산하는 두 가지 방법을 정의한다.

- 첫 번째 방법은 qop 옵션이 빠졌을 때 사용된다. 비밀 정보와 난스가 붙은 메시지 데이터의 해시를 이용해 요약을 계산한다.
- 두 번째 방법은 난스 횟수 집계 및 대칭 인증의 지원을 포함한다. 이 접근법은 'qop'가 'auth'일 때와 'auth-int'일 때 모두 사용된다.
  - 난스 횟수, qop, c난스 데이터를 요약에 추가한다.

<img width="513" alt="13-2" src="https://user-images.githubusercontent.com/75570915/222968970-f1c7c75e-a092-4ae5-8c2b-49519caa5f59.png">

<br />
<br />

## 13.2.6 다이제스트 세션

- 어떤 보호 공간(protection space)을 위한 WWW-Authenticate 인증 요구에 대한 클라이언트 응답은, 그 보호 공간에 대한 인증 세션을 시작하게 한다.
  - 보호 공간은 접근 중인 서버의 루트와 영역(realm)의 결합으로 정의된다.
- 인증 세션은 클라이언트가 보호 공간의 다른 서버로부터 또 다른 WWW-Authenticate 인증요구를 받을 때까지 지속된다.
- 클라는 사용자 이름, 비밀번호, 난스, 난스 횟수(nc), 그리고 보호 공간 내 미래의 요청에 들어갈 Authorization 헤더를 만들기 위해 사용될 인증 세션과 연관된 알아보기 힘든 값들을 기억해야 한다.
- 난스가 만료되면, 서버는 난스 값이 낡은 것임을 감수하고 오래된 Authorizastion 헤더 정보를 받아들이는 것을 택할 수 있다.
- 아니면, 서버는 클라이언트가 다시 요청을 보내도록 새 난스 값과 401을 반환할 수 있다. 이때 이 응답에 `stale=true` 로 정의하여 서버는 클라이언트에게 사용자 이름과 비밀번호를 새로 입력할 필요가 없게 한다.

<br />
<br />

## 13.2.7 사전(preemptive) 인가

일반적인 인증에서는, 각 요청은 트랜잭션이 완료되기 전에 요청/인증 요구 사이클을 필요로 한다.

만약 클라이언트가 다음 난스가 무엇이 될지 미리 알고 있어서, 서버가 물어보기 전에 올바른 Authorization 헤더를 생성할 수 있다면 요청/인증요구 사이클을 생략할 수 있게 된다.

<img width="500" alt="13-3" src="https://user-images.githubusercontent.com/75570915/222969334-e677bcb9-246e-47d0-baad-dbce797f9aaa.png">

<br />

브라우저는 흔히 사용자 이름과 비밀번호 들에 대한 클라이언트 측 데이터베이스를 관리한다. 사용자가 어떤 사이트에 한 번 인증을 하면, 브라우저는 흔히 그 URL에 대한 다음번 요청 때 올바른 Authorization 헤더를 전송한다.

그러나 다이제스트 인증에서 사전 인가는 복잡하다. 난스 기술은 재전송 공격을 저지하기 위한 것이기 때문이다. 서버는 임의 난스를 생성하기 때문에, 인증요구를 받기 전에는 클라이언트가 무엇이 올바른 Authorization 헤더인지 알 방법이 없다. 클라이언트가 새 WWW-Authenticate 인증요구를 기다리지 않고 올바른 난스를 취득할 수 있는 방법이 몇 가지 있다.

- 서버가 다음 난스를 Authenticate-Info 성공 헤더에 담아서 미리 보낸다.
- 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용한다.
- 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 사용한다.

<br />

#### 다음 난스 미리 생성하기

- 서버는 Authentication-Info 성공 헤더로 다음 난스 값을 미리 제공할 수 있다. 서버는 인증이 성공했을 때 200 OK 응답과 함께 헤더를 미리 보낸다.

```
Authentication-Info: nextnonce="<nonce-value>"
```

- 이 다음 난스로 클라이언트는 Authorization 헤더를 미리 만들어 둘 수 있다.
- 사전 인가를 통해 요청/인증요구 사이클에서 벗어날 수 있지만(트랜잭션 속도 향상), 서버에 다중 요청을 파이프라이닝(pipelining)하는 능력은 실질적으로 쓸모가 없어진다. 다음 요청을 보내기 전에 반드시 다음 난스 값을 받아야 하기 때문이다.
  - 파이프라이닝은 회전 지연(latency)를 회피하기 위한 기술이기 때문에 성능상 불이익이 더 커진다.

<br />

#### 제한된 난스 재사용

- 예를 들어 서버는 한 난스를 다섯 번 혹은 10초간 재사용하도록 허락할 수 있다.
- 클라이언트는 자유롭게 Authorization 헤더와 함께 요청을 발행하여 파이프라이닝할 수 있다.
- 난스가 만료되면 서버는 401 Unauthorized 인증요구를 보낼 것이다.
- 이때 `WWW-Authenticate: stale=true` 지시어는 다음과 같이 설정된다.

```
WWW-Authenticate: Digest
  realm="<영역 값>"
  nonce="<난스 값>"
  stale="true"
```

- 난스를 재사용하면 재전송 공격이 성공하기 쉬워지므로 보안성이 감소된다.
- 난스 재사용의 수명은 오랫동안 재사용하도록 통제가 가능하기 때문에 취약점과 성능 간의 트레이드오프가 있을 수 있다.
- 카운터 증가나 IP주소 검사와 같이 다른 기능을 채택할 수 있으나 취약점을 제거할 수는 없다.

<br />

#### 동기화된 난스 생성

제3자가 쉽게 예측할 수 없는 공유된 비밀키(안전 ID 카드처럼)에 기반하면서, 클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록 동기화된 난스 생성 알고리즘을 사용하는 것도 가능하다. 하지만 이 알고리즘들은 다이제스트 인증 명세의 범위를 넘어서는 것이다.

<br />
<br />

## 13.2.8 난스 선택

난스 내용은 불투명하고 구현 의존적이다. RFC 2617은 다음과 같은 가상의 난스 공식을 제안했다.

```
BASE64(타임스탬프 H(타임스탬프 ":" Etag ":" 개인키))
```

타임스탬프는 반복 불가능한 값이면 된다. Etag는 요청된 엔터티에 대한 ETag 헤더값이며, 개인키는 서버만이 알고 있는 값이다.

서버는 클라이언트 인증 헤더를 받은 뒤, 위 공식에서 해시 부분을 재계산하고 클라이언트 인증 헤더의 난스와 일치하지 않거나 타임스탬프가 오래되었다면 요청을 거절한다. 이 방법에서 서버는 난스의 유효 기간을 제한할 수 있다.

ETag를 포함하면 갱신된 리소스에 대한 재요청을 방지한다. 클라이언트 IP주소를 포함해도 되지만, 클라이언트의 요청은 여러 프락시를 거칠 수 있기에 proxy farms(프락시 팜)을 망가뜨릴 수 있고, IP 주소를 쉽게 속일 수 있다. 그리고 이전 난스나 요약을 받아들이지 않거나, 요청 메서드에 따라 다른 요소들을 사용하게 할 수도 있다.

<br />
<br />

## 13.2.9 상호 인증

RFC 2617은 클라이언트가 서버를 인증할 수 있도록 다이제스트 인증을 확장했다. 이는 서버가 공유된 비밀 정보에 근거한 올바른 응답 요약을 생성할 수 있도록, 클라이언트 난스(c난스) 값을 제공함으로써 가능해진다. 이후 서버는 이 요약을 Authentication-Info 헤더를 통해 클라이언트에 전달한다.

상호 인증은 qop 지시자가 존재할 경우 항상 수행하고, 없다면 수행하지 말아야 한다. 응답 요약은 메시지 본문 정보(A2)가 다르다는 것만 제외하면 요청 요약과 같은 방법으로 계산한다. A2가 다른 이유는 응답에는 HTTP 메서드가 없고 메시지 엔터티 데이터가 다르기 때문이다.
