# 15.8 검사기와 신선도

## 1. 신선도(15.8.1)

- 서버는 클라이언트에게 얼마나 오랫동안 콘텐츠를 캐시하고 그것이 신선하다고 사정할 수 있는지에 대한 정보를 줄 것임
  - 서버는 `Expires` 나 `Cache-Control` 헤더를 통해 이러한 정보를 줄 수 있다
- `Expires 헤더` : 문서가 만료되어 더 이상 신선하다고 간주할 수 없게 되는 정확한 날짜를 명시
  - 문법
  ```
  Expires: Sun Mar 18 23:59:59 GMT 2001
  ```
- Expires 헤더를 바르게 사용하는 클라이언트나 헤더는, 그들의 시계를 반드시 동기화시켜야 한다
  - 이게 항상 쉽지는 않다!
    ⇒ 네트워크 시간 프로토콜과 같은 시계 동시화 프로토콜을 실행하지 않았을 가능성이 양쪽 모두에게 있기 때문
    ⇒상대시간을 이용해 만료를 정의하는 메커니즘이 더 쓸만하다
- `Cache-Control 헤더`: 문서의 최대 수명을 문서가 서버를 떠난 후로부터의 총 시간을 초 단위로 정한다
  - 수명은 시계 동기화에 의존하지 않으므로 더 정확한 결과를 말해줄 것
  - Cache-Control 헤더는 실제로 굉장히 강력하다. 서버와 클라이언트 양쪽에서 더 많은 지시자들과 함께, 단지 수명이나 유효기간뿐 아니라 선도(신선도)를 서술하기 위해 사용된다

## 2. 조건부 요청과 검사기(15.8.2)

- 캐시의 사본이 요청되었을 때 그것이 더 이상 신선하지 않다면 `캐시는 자신이 갖고 있는 사본을 신선한 것으로 만들 필요`가 있다
- 캐시는 원 서버에서 현 시점의 사본을 가져올 수 있지만 대개 서버에 있는 문서는 여전히 캐시에 들어있는 신선하지 못한 사본과 같을 것이다
- 캐시된 사본은 만료될 수 있지만 서버 콘텐츠는 여전히 캐시 콘텐츠와 같다
- `만약 서버의 문서가 캐시가 갖고 있는 것과 같음에도 불구하고 항상 그 문서를 가져온다면 캐시는 네트워크의 대역폭을 낭비하고 캐시와 서버에 불필요한 부하를 주고 모든 것을 느려지게 만들게 된다`

⇒ 이를 고치기 위해 HTTP 는 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라 불리는 특별한 요청을 할 수 있는 방벙블 제공한다

- 조건부 요청은 평범한 HTTP 요청 메시지이지만 특정 조건이 참일 때에만 수행된다
  - ex) 캐시는 다음의 조건부 GET 메시지를 서버에 보내서, /announce.html 파일이 2002년 6월 29일(캐시된 문서가 작성자에 의해 마지막으로 변경된 날짜) 이후에 변경된 경우메나 한해서 파일을 보내달라고 할 수 있다
  ```
  GET /announce.html HTTP/1.0
  If-Modified-Since: Sat, 29 jun 2002, 14:30:00 GMT
  ```
- 조건부 요청을 `‘If-’` 로 시작하는 조건부 헤더에 의해 구현된다
- 위의 예에서, 조건부 헤더는 `If-Modified-Since` 며 조건부 헤더는 조건이 참일 때만 수행되도록 한다
  - 만약 `조건이 참이 아니면 서버는 HTTP 에러코드를 돌려보낸다`
- 각 조건부 요청은 특정 검사기 위에서 동작한다
- 검사기는 문서의 테스트된 특정 속성이다
- 개념적으로, 일련번호나 버전 번호 혹은 문서의 최종 변경일과 같은 검사기를 생각해볼 수 있다
- If-Modified-Since 상태헤더는 문서 인스턴스의 마지막 수정된 날짜를 검사하므로, 우리는 마지막 수정된 날짜를 검사기라고 말할 수 있다
- If-None-Match 조건부 헤더는 문서의 ETag 값을 평가한다
  - ETag 는 특별한 키워드이거나 엔터티와 관련된 버전 식별 태그이다
- Last-Modified 와 ETag 는 HTTP 에 의해 사용되는 두개의 주요한 검사기
- `조건부 요청을 위해 사용되는 네가지 헤더`

| 요청 유형           | 검사기        | 설명                                                                                                                                |
| ------------------- | ------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| If-Modified-Since   | Last-Modified | 지난번 Last-Modified 응답 헤더에 들어있었던 시각에 마지막으로 수정된 버전이 더 이상 최신 버전이 아니라면, 그 리소스의 사본을 보내라 |
| If-Unmodified-Since | Last-Modified | 지난번 Last-Modified 응답 헤더에 들어있었던 시각에 마지막으로 수정된 버전에서 변한 것이 없다면 그 리소스의 사본을 보내라            |
| If-Match            | ETag          | 지난번 ETag 응답 헤더에 들어있었던 것과 엔터티 태그가 같다면 그 리소스의 사본을 보내라                                              |
| If-None-Match       | ETag          | 지난번 ETag 응답 헤더에 들어있었던 것과 엔터티 태그가 다르다면, 그 리소스의 사본을 보내라                                           |

- HTTP 는 검사기를 약한 검사기와 강한 검사기의 두 가지로 분류한다
- `약한 검사기`
  - 리소스의 인스턴스를 고유하게 식별하지(uniquely identify) 못하는 경우도 있다
  - 예: 객체의 바이트 단위 크기. 리소스 콘텐츠는 크기가 같더라도 내용이 다를 수 있으므로 바이트의 개수를 세는 방식으로 동작하는 가상의 횟수 검사기는 변경이 발생했음을 약하게만 감지할 수 있다
- `강한 검사기`
  - 언제나 고유하게 식별한다
  - 예: 리소스의 콘첸츠에 대한 암호 체크섬은 강한 검사기다. 이것은 문서가 변경되면 함께 변경됨
- 최종 변경 시각은 리소스가 마지막으로 수정된 시간을 의미함에도 불구하고 `약한 검사기`로 간주되는데, `정확도가 최대 1초에 불과하기 때문`
  - 리소스는 1초에 여러번 변경될 수 있고 서버는 1초에 수천번의 요청을 처리하기 때문에 최종변경 시각은 변경이 발생했음을 항상 반영해주지는 못한다
- ETag 헤더는 `강한 검사기`로 간주되는데, `서버는 ETag 헤더에 매 변경마다 구분되는 값`을 넣어두기 때문이다
  - 버전 번호와 요약 체크섬은 ETag 헤더의 좋은 후보이지만 그 외의 어떤 텍스트도 포함할 수 있다
  - ETag 헤더는 유연하다. 어떤 텍스트 값도 가질 수 있고(’tags’) 클라이언트와 서버의 다양한 검사를 창안하기 위해 사용될 수 있다
- `클라이언트와 서버는 때때로 엔터티 태그 검사를 통과하지 못한 버전을 채택하는 경우`가 있다. 예를 들어, 서버는 크고 자주 찾는 캐시된 문서에 대해 캐시의 재검사로 인한 대량 전송을 유발하지 않으면서 겉모양새만 약간 고치고 싶을 수도 있다. 이 경우 서버는 태그 앞에 ‘W/’를 붙임으로써 약한 엔터티 태그임을 알린다. 약한 엔터티 태그는 엔터티의 의미상 두드러진 변화에만 사용할 수 있다. 강한 엔터티 태그는 관련된 엔터티 값이 아무리 사소하게 바뀌었더라도 함께 변경되어야 한다.
- 요약하면, 클라이언트가 같은 리소스에 한 번 이상 접근했을 때, 우선 현재 사본이 여전히 `신선한지` 판별한다. 만약 그렇지 않다면, 클라이언트는 반드시 서버로부터 최신 버전을 얻어와야 한다. 리소스가 변경되지 않은 상황에서 똑같은 사본을 다시 받아오는 상황을 피하기 위해 클라이언트는 서버에 현재 사본을 유일하게 식별할 수 있는 검사기를 명시해서 조건부 요청을 보낼 수 있다. 서버는 오직 클라이언트의 사본과 다를 때만 리소스의 사본을 보낼 것이다.
