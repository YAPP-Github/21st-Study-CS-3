# 15.6 전송 인코딩과 청크 인코딩

- 메시지 본문에 적용된 가역적 변환인 `콘텐츠 인코딩`은 콘텐츠 포맷과 관련있음
  - 텍스트 파일은 흔히 gzip으로 압축하지만 JPEG 파일은 gzip으로 잘 압축되지 않기 때문에 사용하지 않는다.
- 전송 인코딩 : 엔터티 본문에 적용되는 가역적 변환이지만, 그들은 구조적인 이유 때문에 적용되는 것이며 **콘텐츠의 포맷과는 독립적**이다.
![image](https://user-images.githubusercontent.com/101736358/226318644-8e224b27-0102-4a73-a512-87c28eb323d0.png)

- 콘텐트 인코딩 : 엔터티 헤더는 바뀌지 않고 엔터티 본문만 인코딩
- 전송 인코딩 : 전체 메시지를 인코딩하여 메시지 자체의 구조를 바꿈
- 메시지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메시지에 적용

## 15.6.1 안전한 전송
- 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 '안전한 전송'을 위해 존재했다.

1. 알 수 없는 크기

- 몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 **메시지 본문의 최종 크기**를 판단할 수 없다.
- 이 서버들은 그 사이즈를 알기 전에 데이터의 전송을 시작하려고 한다.
- HTTP는 데이터에 앞서 `Content-Length` 헤더를 요구하기 때문에, 몇몇 서버는 데이터의 끝을 알리는 **종결 꼬리말**을 포함시켜 전송 인코딩으로 데이터를 보내려 시도한다.
   - 종결 신호로 간주하고 커넥션을 끊을 수도 있음(커넥션이 망가짐)

2. 보안
- 공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 `전송 인코딩`을 사용해 알아보기 어렵게 뒤섞는 방법도 있음 
- SSL 같은 전송 계층 보안 방식을 주로 사용한다.

## 15.6.2 2 Tranfer-Encoding 헤더
- 전송 인코딩을 제어하고 서술하기 위해 정의된 헤더 두 가지
1. Transfer-Encoding
- 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.
- `Content-encoding` 과 유사
2. TE
- 어떤 확장된 전송 인코딩을 사용할 수 있는지 클라이언트가 서버에게 알려주기 위해 요청 헤더에 사용
- `Accept-Encoding` 헤더와 유사 (q 값을 가질 수 있음)

```
TE 헤더 사용 예

GET /new_products.html HTTP/1.1
Host: www.joes-hardware.com
User-Agent: Mozilla/4.61
TE: trailers, chunked
[chunked-encoded 메시지와 메시지의 끝에 트레일러가 오는 것을 받아들일 수 있음을 서버에게 알려주기 위해 작성]

Transfer-Encoding 헤더 사용 예

HTTP/1.1 200 OK
Transfer-Encoding: chunked
Server: Apache/3.0
[이 기초 헤더 뒤에 메시지 구조가 변함]
```

## 15.6.3 청크 인코딩
- 청크 인코딩은 전송 인코딩의 한 형태로 메시지를 일정 크기의 청크 여럿으로 **쪼갠다**. 
- 본문 전체를 보낼때까지 서버는 각 청크를 순차적으로 보낸다.
- 청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다.
- 청크 인코딩이 전송 인코딩의 한 형태이며 본문이 아닌 메시지의 속성임에 주목해야 한다.

**청크와 지속 커넥션**

- 지속 커넥션에서는 본문을 쓰기 전에 반드시 `Content-Length` 헤더에 본문의 길이를 담아서 보내줘야 한다.
- 콘텐츠가 서버에서 동적으로 생성되는 경우에는, 보내기 전에 본문의 길이를 알아내는 것이 불가능할 것이다.

- **청크 인코딩**은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해주기 떄문에 해결 가능!
  - 동적으로 본문이 생성될지라도, 서버는 그중 일부를 버퍼에 담은 뒤 그 한 덩어리를 그의 크기와 함께 보낼 수 있다.
  - 본문을 모두 보낼때까지 이 과정을 반복하다 본문이 끝났음 알리기 위해 크기가 0인 청크를 마지막을 보냄

![image](https://user-images.githubusercontent.com/101736358/226328796-2ab8cd8c-070d-4c36-9714-b4a096fdfed4.png)

- 청크 인코딩을 활용한 응답 메시지 :  HTTP 응답헤더로 시작 / 청크 안에는 길이 값(바이트 값)
과 청크에 대한 데이터를 담고 있음 

**청크 인코딩된 메시지의 트레일러**

- 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내는 경우
- 트레일러가 응답을 만든 서버에 의해 추가되었으며, 그 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할 필요가 없는 선택적인 메타데이터이므로 클라이언트가 무시하고 버려도 되는 경우
  - `Trailer` 헤더의 경우 청크 인코딩의 초기 버전보다 나중에 나왔기 때문에 `Trailer` 헤더를 이해하지 못하는 경우

  - 트레일러에는 본문의 콘텐츠가 먼저 생성되어야 한다거나 하는 등의 이유로 메시지 시작 시점에서는 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다.
  - ex. `Content-MD5`
    - `Content-MD5` 헤더는 문서가 생성되기 전에 그 문서의 MD5를 계산하기 어렵기 때문에 트레일러를 이용할 수 있다.
    >
    `Content-MD5` 헤더는 HTTP 응답에서 본문 데이터의 MD5 해시 값을 포함하는 헤더입니다. 이 헤더는 클라이언트 측에서 전송된 데이터의 무결성을 확인하기 위해 사용됩니다.
    서버는 Content-MD5 헤더를 사용하여 데이터가 제대로 전송되었는지 확인하고, 클라이언트는 서버가 제공한 MD5 해시 값을 사용하여 전송된 데이터의 무결성을 검증합니다. 이를 통해 데이터가 전송 중에 손상되거나 변경되었는지 확인할 수 있습니다.

 - 마지막 청크 다음에 Trailer 헤더에 나열했던 헤더들이 온다.

> - message framing headers: Transfer-Encoding, Content-Length
> - routhing headers: Host
> - request modifiers: Control-Cache, Max-Forwards, TF
> - authentication headers: Authorization, Set-Cookie
> - etc: Content-Encoding, Content-Type, Content-Range, Trailer(itself)

## 15.6.4 콘텐츠 전송 인코딩의 조합
- 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.
- `콘텐츠 인코딩`을 사용해서 HTML 파일을 압축하고 압축된 데이터를 청크 데이터로 쪼개서 전송 인코딩을 사용해서 전송

## 15.6.5 전송 인코딩 규칙
- 전송 인코딩의 집합은 반드시 'chunked'를 포함해야 한다.
- 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.
- 전송 인코딩은 http/1.1 소개된 기능
- 서버는 http/1.1 이 아닌 클라이언트에게는 전송 인코딩을 사용해선 안됨