# 8.5 터널

웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방식을 제공한다.

웹 터널을 사용하면 **HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴 수 있다.** 웹 터널을 사용하는 가장 일반적인 이유는 **HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위해서다.**

따라서 웹 트래픽만을 허락하는 방화벽이 있더라도 HTTP가 아닌 트래픽을 전송할 수 있다.

<br />
<br />

### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

웹 터널은 **HTTP의 CONNECT 메서드를 사용하여 커넥션을 맺는다.** 

<img width="500" alt="터널_01" src="https://user-images.githubusercontent.com/75570915/212480533-8ecf9878-bd4c-4388-b600-182df70b052d.png">

<br />

#### CONNECT 요청

CONNECT 문법은 시작줄을 제외하고는 다른 HTTP 메서드와 같다. 요청 URI는 호스트 명이 대신하며 콜론에 이어 포트를 기술한다.

```
CONNECT home.netscape.com:443 HTTP/1.0
User-Agent: Mozilla/4.0
```

<br />

#### CONNECT 응답

클라이언트는 요청 이후 게이트웨이의 응답을 기다린다. 일반 HTTP 메시지와 같이 200 응답 코드를 받는다.

```
HTTP/1.0 200 Connection Established
Proxy-agent: Netscape-Proxy/1.1
```

일반적인 HTTP 응답과는 달리 **Content-Type 헤더를 포함할 필요는 없다.** 바이트를 그대로 전달하기 때문에 콘텐츠의 형식을 기술하는 Content-Type 헤더가 필요없는 것이다.

<br />
<br />

### 8.5.2 데이터 터널링, 시간, 커넥션 관리

터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서, 게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 할 수 없다. 터널이 일단 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있다.

클라이언트는 **성능을 높이기 위해 CONNECT 요청을 보낸 다음, 응답을 받기 전에 터널 데이터를 전송할 수 있다.** 이는 게이트웨이가 요청에 이어서 데이터를 적절하게 처리할 수 있어야 함을 전제로 한다.

요청 후에 터널을 통해 데이터를 전송한 클라이언트는 인증 요구(authentication challenge)나 200 외의 응답이 왔을 때 요청 데이터를 보낼 준비가 되어 있어야 한다.

<br />
<br />
 
### 8.5.3 SSL 터널링

웹 터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발되었다. 터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP만을 허용하는 방화벽을 통과시킬 수 있다.

<img width="502" alt="터널_03" src="https://user-images.githubusercontent.com/75570915/212481328-779b67f6-6a0c-498f-bd68-f4e7709116ef.png">

<br />

두번째 그림에서, SSL 트래픽은 일반 SSL 커넥션을 통해 전송되기 전까지는 HTTP 메시지에 담겨 HTTP 포트인 80에 전송된다. 

터널은 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해준다.

<img width="501" alt="터널_03-2" src="https://user-images.githubusercontent.com/75570915/212481326-48bcf847-031d-4ecd-857e-3c80188c5808.png">

<br />
<br />

### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

HTTPS 프로토콜은 다른 프로토콜(ex. http, ftp 등)과 같은 방식으로 게이트웨이를 통과할 수 있다. 게이트웨이(클라이언트 대신)를 두고 클라이언트 측의 HTTPS 트랜잭션을 수행하는 방식이다. 응답은 프락시가 받아서 복호화하고 난 후에, HTTP를 통해 클라이언트로 전송한다. 하지만 이 접근은 몇 가지 단점이 있다.

- 클라이언트와 게이트웨이 사이에는 **보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져 있다.**
- 프락시가 인증을 담당하고 있기 때문에, 클라이언트는 **원격 서버에 SSL 클라이언트 인증을 할 수가 없다.**
- 게이트웨이는 SSL을 완벽히 지원해야 한다.

이 상황에서 SSL 터널링을 사용하면, 프락시에 SSL을 구현할 필요가 없다.
