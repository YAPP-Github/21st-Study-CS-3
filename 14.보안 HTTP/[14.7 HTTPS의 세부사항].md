# 14.7 HTTPS의 세부사항

## 1. 개요

- `HTTPS`는 `HTTP의 가장 유명한 보안 버전`
- `HTTPS`는 `HTTP프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합`한 것

## 2. HTTPS 개요(14.7.1)

- `HTTPS`는 그냥 `보안 전송 계층을 통해 전송되는 HTTP`
- 암호화되지 않은 HTTP메시지를 TCP를 통해 전 세계의 인터넷 곳곳으로 보내는 대신에 HTTPS는 HTTP메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보낸다
  ![IMG_8E3EE1D5A55B-1.jpeg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/440ebfc6-7e41-4c90-b25f-ef3aed5c7b2e/IMG_8E3EE1D5A55B-1.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230320%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230320T125323Z&X-Amz-Expires=86400&X-Amz-Signature=38cbf584dd2dbec13c798d28c605e1083f253e704f283468c0e38bb9d64b754c&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22IMG_8E3EE1D5A55B-1.jpeg%22&x-id=GetObject)
- 오늘날 `HTTPS의 보안 계층은, SSL 과 그것의 현대적 대체품인 TLS로 구현`되었다
- 책에서는 `SSL과 TLS 모두`를 의미하는 단어로 `SSL`을 사용하는 관행 따를 것!

## 3. HTTPS 스킴(14.7.2)

- 오늘날 `보안 HTTP는 선택적`
- 웹 서버로의 요청을 만들 때, 우리는 웹 서버에게 HTTP 의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요하다
  - 이것은 URL의 스킴을 통해 이루어진다
- `보안이 없는 일반적인 HTTP`는 URL 의 스킴 접두사는 `http`
- `보안이 되는 HTTPS 프로토콜`에서 URL의 스킴 접두사는 다음과 같이 `https`
- (웹브라우저 등의) 클라이언트는 웹 리소스에 대한 트랜잭션 수행을 요청받으면 URL의 스킴을 검사한다
  - 만약 URL이 http 스킴을 갖고 있다면 클라이언트는 서버에 80번(기본값)포트로 연결하고 평범한 HTTP 명령을 전송한다
  - 만약 URL이 https 스킴을 갖고 있다면, 클라이언트는 서버에 443번(기본값) 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 ‘핸드셰이크’를 하고 암호화된 HTTP 명령이 뒤를 잇는다
- SSL 트래픽은 `바이너리 프로토콜`이기 때문에 HTTP와는 완전히 다르다, 그 트래픽은 다른 포트(SSL은 보통 443 포트를 통해 전달)로 전달된다
  - 만약 SSL 과 HTTP 트래픽 모두가 80번 포트로 도착한다면 대부분의 웹브라우저는 바이너리 SSL 트래픽을 잘못된 HTTP 로 해석하고 커넥션을 닫을 것이다
  - 보안 서비스가 HTTP쪽으로 좀 더 계층 통합이 되도록 하면 포트가 둘 이상 필요할 이유가 사라지겠지만 사실 이것이 그렇게 심각한 문제를 일으키지는 않는다

## 4. 보안 전송 셋업(14.7.3)

- 암호화되지 않은 HTTP에서 클라이언트는 웹 서버의 80번 포트로 TCP 커넥션을 열고 요청 메시지를 보내고 응답 메시지를 받고 커넥션을 닫는다
- HTTPS에서의 절차는 SSL 보안 계층 때문에 약간 더 복잡하다
- HTTPS에서 클라이언트는 먼저 웹 서버의 443 포트로 연결한다
- TCP 연결이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다
- 핸드셰이크가 완료되면 SSL 초기화는 완료되며 클라이언트는 요청메시지를 보안계층에 보낼 수 있다
  ![IMG_343E8F43E768-1.jpeg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/43c2cb98-ba45-4244-927f-58505f429a1c/IMG_343E8F43E768-1.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230320%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230320T125336Z&X-Amz-Expires=86400&X-Amz-Signature=a6c4570d9839ace5d1eb77e1da47875b94179d9cbc8ee3e41cfef0f37e6777b6&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22IMG_343E8F43E768-1.jpeg%22&x-id=GetObject)

## 5. SSL 핸드셰이크(14.7.4)

- 암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다
  - 프로토콜 버전 번호 교환
  - 양쪽이 알고 있는 암호 선택
  - 양쪽의 신원을 인증
  - 채널을 암호화하기 위한 임시 세션 키 생성
- 암호화된 HTTP 데이터가 네트워크를 오가기도 전에, SSL 은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고받는다
- SSL 핸드셰이크의 핵심

  ![IMG_4D64D41740C1-1.jpeg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/ed07c6eb-272f-437a-bb80-fba3416e07b4/IMG_4D64D41740C1-1.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230320%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230320T125408Z&X-Amz-Expires=86400&X-Amz-Signature=31b10f714ad33a1d070e93c514d64bad9ec8c831c85d2d4df08911184e50837d&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22IMG_4D64D41740C1-1.jpeg%22&x-id=GetObject)

- 이것은 SSL 핸드셰이크를 단순화한 버전
- SSL 이 어떻게 사용되는가에 따라 핸드셰이크는 보다 복잡해질 수 있긴 하지만 일단 여기서는 일반적인 개념을 보여주고 있다

## 6. 서버 인증서(14.7.5)

- SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호인증을 지원한다
- 그러나 오늘날 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이지 않는다
- 대부분의 사용자는 개인 클라이언트 인증서를 갖고 있지도 않다
- 웹 서버는 클라이언트 인증서를 요구할 수 있지만 실제로는 좀처럼 일어나지 않는 일이다
- 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다
- 누군가가 웹 서버에 신용카드 정보를 보내는 것과 같은 보안 트랜잭션을 수행할 때, 그는 대화 중인 조직이 그와 대화하고 있다고 생각한 그 조직이 맞는지 알고 싶을 것이다. 잘 알려진 인증기관에 의해 서명된 서버 인증서는 그가 서버에 그의 신용카드나 개인 정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는 것을 도와줄 것이다
- 서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그리고 그 외의 정보를 보여주는 X.509 v3 에서 파생된 인증서이다
- 사용자와 사용자의 클라이언트 소프트웨어는 모든 것이 믿을만한 것인지 확인하기 위해 인증서를 검증할 수 있다

## 7. 사이트 인증 검사(14.7.6)

- SSL자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만 최신 웹브라우저들 대부분은 인증서에 대해 간단하게 기본적인 검사를 하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다
- 넷스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘은 대부분의 웹브라우저의 검사 기법의 기초를 구축했다
- 알고리즘의 수행단계는 다음과 같다

### 날짜 검사

- 브라우저는 인증서가 여전히 유효함을 확인하기 위해 인증서의 시작 및 종료일을 검사한다. 만약 인증서가 만료되었거나 아직 활성화되지 않았다면 인증서 검사는 실패하고 브라우저는 에러를 보여준다

### 서명자 신뢰도 검사

- 모든 인증서는 서버를 보증하는 어떤 인증 기관에 의해 서명되어 있다
- 여러가지 수준의 인증서가 있는데 각각은 다른 수준의 배경 검증을 요구한다
- Ex. 전자상거래 서버 인증서를 발급박고자 한다면 사업체로서의 법인에 대한 법적 증명을 제시해야 한다

### 서명 검사

- 한번 서명 기관이 믿을만하다고 판단하면 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다

### 사이트 신원 검사

- 서버가 누군가 다른 이의 인증서를 복사하거나 그들의 트래픽을 가로채는 것을 방지하기 위해 대부분의 브라우저는 인증서의 도메인 이름이 대화중인 서버의 도메인 이름과 비교하여 맞는지 검사한다
- 서버 인증서에는 보통 단일 도메인 이름이 들어있지만 몇몇 CA는 서버 클러스터나 서버 팜을 위해 서버 이름의 목록이나 서버 이름들에 대한 와일드카드 표현이 들어있는 인증서를 만든다

## 8. 가상 호스팅과 인증서(14.7.7)

- 가상 호스트(하나의 서버에 여러 호스트 명)로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 많다
- 몇몇 인기있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원한다
- 만약 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트 명에 도착했다면 경고 상자가 나타날 것이다!
